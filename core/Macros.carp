(defdynamic cond-internal [xs]
  (if (= (count xs) 0)
    (list)
    (if (= (count xs) 2)
      (list)
      (if (= (count xs) 1)
        (car xs)
        (list
         'if
         (car xs)
         (car (cdr xs))
         (cond-internal (cdr (cdr xs))))))))

(defmacro cond [:rest xs]
  (cond-internal xs))

(defmacro for [settings body] ;; settings = variable, from, to, <step>
  (list
   'let
   (array (car settings) (car (cdr settings)))
   (list
    'while
    (list 'Int.< (car settings) (car (cdr (cdr settings))))
    (list 'do
          body
          (list
           'set! (list 'ref (car settings))
           (list 'Int.+
                 (car settings)
                 (if (= 4 (count settings)) ;; optional arg for step
                   (car (cdr (cdr (cdr settings))))
                   1)))))))

(defmacro refstr [x]
  (list 'ref
        (list 'str x)))

(defmodule Array
  (defmacro foreach [f xs]
    (list 'let
          (array
           'temp
           (list 'Array.transform f xs))
          ())))
