; missing: lerp


(defdynamic append-multi- [strs]
  (if (= (count strs) 0)
    '@""
    (list 'String.append (car strs) (append-multi- (cdr strs)))))

(defmacro append-multi [:rest strs]
  (append-multi- strs))

(defmodule Vector2
  (deftype V [x Double, y Double])

  (defn init [x, y]
    (V.init x y))

  (defn str [o]
    (append-multi @"Vector2(" (Double.str (V.x o)) @", " (Double.str (V.y o)) @")"))

  (defn + [a, b]
    (V.init (Double.+ (V.x a) (V.x b))
            (Double.+ (V.y a) (V.y b))))

  (defn - [a, b]
    (V.init (Double.- (V.x a) (V.x b))
            (Double.- (V.y a) (V.y b))))

  (defn * [a, n]
    (V.init (Double.* (V.x a) n)
            (Double.* (V.y a) n)))

  (defn / [a, n]
    (V.init (Double./ (V.x a) n)
            (Double./ (V.y a) n)))

  (defn doubeq [a, b]
    (if (Double.> a b)
      (Double.< (Double.- a b) 0.00001)
      (Double.< (Double.- b a) 0.00001)))

  (defn = [a, b]
    (and (doubeq (V.x a) (V.x b))
         (doubeq (V.y a) (V.y b))))

  (defn mag-sq [o]
    (let [x (V.x o)
          y (V.y o)]
      (Double.+ (Double.* x x) (Double.* y y))))

  ;(defn mag [o]
  ;  (Double.sqrt (mag-sq o)))

  ;(defn normalize [o]
  ;  (let [m (mag o)]
  ;    (if (= m 0)
  ;      o
  ;      (div o n))))

  ;(defn dist [a, b]
  ;  (let [b (- b a)]
  ;    (mag b)))

  ;(defn heading [a]
  ;  (Double.atan2 (V.y a) (V.x a)))

  ;(defn rotate [a n]
  ;  (let [h (Double.+ (heading a) n)
  ;        m (mag a)]
  ;    (V.init (Double.* (Double.cos h) m) (Double.* (Double.sin h) m))))

  (defn dot [x, y]
    (Double.+ (Double.* (V.x x) (V.x y))
              (Double.* (V.y x) (V.y y))))

  ;(defn angle-between [a b]
  ;  (let [dmm (Double./ (dot a b) (Double.* (mag a) (mag b)))]
  ;    (Double.acos (Double.clamp -1.0 1.0 dmm))))
)

(defmodule Vector3
  (deftype V [x Double, y Double, z Double])

  (defn init [x, y, z]
    (V.init x y z))

  (defn str [o]
    (append-multi @"Vector2(" (Double.str (V.x o)) @", " (Double.str (V.y o)) @", " (Double.str (V.z o)) @")"))

  (defn + [a, b]
    (V.init (Double.+ (V.x a) (V.x b))
            (Double.+ (V.y a) (V.y b))
            (Double.+ (V.z a) (V.z b))))

  (defn - [a, b]
    (V.init (Double.- (V.x a) (V.x b))
            (Double.- (V.y a) (V.y b))
            (Double.- (V.z a) (V.z b))))

  (defn * [a, n]
    (V.init (Double.* (V.x a) n)
            (Double.* (V.y a) n)
            (Double.* (V.z a) n)))

  (defn / [a, n]
    (V.init (Double./ (V.x a) n)
            (Double./ (V.y a) n)
            (Double./ (V.z a) n)))

  (defn mag-sq [o]
    (let [x (V.x o)
          y (V.y o)
          z (V.z o)]
      (Double.+ (Double.* x x) (Double.+ (Double.* y y) (Double.* z z)))))

  ;(defn mag [o]
  ;  (Double.sqrt (mag-sq o)))

  ;(defn normalize [o]
  ;  (let [m (mag o)]
  ;    (if (= m 0)
  ;      o
  ;      (div o n))))

  (defn cross [x, y]
    (V.init
      (Double.- (Double.* (V.y x) (V.z y))
                (Double.* (V.z x) (V.y y)))
      (Double.- (Double.* (V.z x) (V.x y))
                (Double.* (V.x x) (V.z y)))
      (Double.- (Double.* (V.x x) (V.y y))
                (Double.* (V.y x) (V.x y)))))

  (defn dot [x, y]
    (Double.+ (Double.* (V.x x) (V.x y))
              (Double.+ (Double.* (V.y x) (V.y y))
                        (Double.* (V.z x) (V.z y)))))

  ;(defn angle-between [a b]
  ;  (let [dmm (Double./ (dot a b) (Double.* (mag a) (mag b)))]
  ;    (Double.acos (Double.clamp -1.0 1.0 dmm))))
)

;(defmodule VectorN
;  (deftype V [n Int, v (Array Double)])
;
;  (defn init [n, v]
;    (V.init n v))
;
;  (defn str [o]
;    (append-multi @"VectorN(dim=" (Int.str (V.n o)) ;", vals=" (Array.str (V.v o))
;                  @")"))
;
;  (register zip- (Fn [(Fn [Double, Double] Double) &(Array Double) &(Array Double)] V))
;  (defn zip- [f, a, b]
;    (let [total []]
;      (do
;        (for [i 0 (Array.count a)]
;          (set! &total (Array.push-back (Array.copy &total) (f (Array.nth a i) (Array.nth b i)))))
;        (V.init (Array.count a) total))))
;
;  (register zip (Fn [(Fn [Double, Double] Double) &V &V] V))
;  (defn zip [f, a, b]
;    (if (Int.= (V.n a) (V.n b))
;      (zip- f (V.v a) (V.v b))
;      (do
;        (IO.println "Error: vectors are of wrong dimensionality")
;        (V.copy a))))
;
;  (defn + [a, b]
;    (zip add- a b))
;
;  (defn - [a, b]
;    (zip Double.- a b))
;
;  (defn * [a, n]
;    (zip- Double.* (V.v a) &(Array.repeat (V.n a) n)))
;
;  (defn / [a, n]
;    (zip- Double./ (V.v a) &(Array.repeat (V.n a) n)))
;
;  (defn square- [n]
;    (Double.* (Double.copy n) (Double.copy n)))
;
;  (defn add- [x, y]
;    (Double.+ (Double.copy x) (Double.copy y)))
;
;  (defn mag-sq [o]
;    (Array.reduce add- 0.0 &(Array.copy-map square- (V.v o))))
;
;  ;(defn mag [o]
;  ;  (Double.sqrt (mag-sq o)))
;
;  ;(defn dist [a, b]
;  ;  (let [b (- b a)]
;  ;    (mag b)))
;
;
;  ;(defn normalize [o]
;  ;  (let [m (mag o)]
;  ;    (if (= m 0)
;  ;      o
;  ;      (div o n))))
;)
