# Todo

## Milestones
* 0.3 - Hopefully done "soon", fixing the most pressing issues.
* 0.4 - A nice minimal version of the language. Should be possible to use for somewhat realistic projects.
* 1.0 - The completed version of the language with all planned features and extra nice ergonomics.

## Critical Bugs
* [0.3] References must keep track of their origin and prevent usage of them if the origin has been given away.
* [0.3] Can set a ref so it points to a value in a more short-lived scope, leads to 'stack-use-after-scope' error in clang-sanitizer.
* [0.3] The error reporting in Eval is a mess, must make it possible to return errors with correct location for all kinds of errors.
* [0.3] This hangs the repl: `(expand '(load-and-use SDL))`
* [0.3] Some kind of memory allocation when using 'foreach' macro in ant.carp ??!

## Big Language Features
* [0.4] Doc strings and type annotations.
* [0.4] Stack allocated Array with an explicit size.
* [0.4] Deps function for templates should return an Either to enable errors when instantiating deps.

* [1.0] Good hashmap implementation with support for "{}" syntax.
* [1.0] Tagged unions (also known as "sum types" or "enums")
* [1.0] Lambdas (anonymous functions) that compile on Windows and don't leak memory!

## Smaller Language Features ("niceties")
* [0.4] Handle self-referencing members in structs (also for function types, i.e. "(deftype Foo [f (Fn [Foo] Foo)])")
* [0.4] Array.copy should just do a memcopy for primitive/plain types. Select most concrete version of 'copy'?
* [0.4] If main returns the value of a function returning a generic type it will fail (because there is no constraint for "Int or ()")
* [0.4] Errors in macros should present the code location of both the macro and of the code that uses of it.
* [0.4] Returning refs in functions should be possible to prove safe in some cases, if origin or ref is stored during memory management pass.
* [0.4] Should be possible to read float literal without '.', eg. "3f" (because that's how they print sometimes)
* [0.4] Defining a local variable messes up unqualified lookup of function with the same name, e.g. (let [words (words &s)] ...)
* [0.4] Defining a function like 'add-ref' (see the numeric modules), refering to '+' does not resolve to '+' inside the module, which gives the function an overly generic type.
* [0.4] Report correct column in errors at all times, sometimes it's a bit too low.
* [0.4] Array.init-empty-with-capacity function. What's a better name?
* [0.4] Undefined symbol does not stop execution when running with -x
* [0.4] A way of telling Carp if an external type is primitive (and thus freely copy:able) or not and must be borrowed.

* [1.0] Macros for generating 'read' functions to read objects back into memory from string representation.
* [1.0] A way to assert compiler errors in tests
* [1.0] Rename type variables from t0, t1, t2 to a, b, c, etc.
* [1.0] Kind-checking for types (make sure the type variables match, etc).
* [1.0] Allow unification of generic struct '(t a)' with concrete struct, i.e. (Array Int).

## Macro System
* [1.0] Quasiquote
* [1.0] Splicing in macros
* [1.0] Pattern matching on arguments in macros?
* [1.0] Some lists and similar things generated by built in dynamic functions like 'cons' etc don't create proper Info for their XObjs?

## Tooling
* [0.4] Make the flags sent to the compiler be saved into different groups depending on actual compiler.
* [0.4] Hide instances of templates/generic functions when printing the environment (by default, allow it as a setting).
* [0.4] Entering the name of a symbol at the REPL prints nothing.
* [0.4] Show "call stack" when getting an error during concretization.
* [0.4] Allow echoing of infered type at the REPL (must be silenced when loading a file though)
* [0.4] Only reload files once, keep track of which ones have already been reloaded.
* [0.4] Prevent run if no exe has been successfully built.
* [0.4] Flycheck hangs and eats all resources sometimes.

* [1.0] Project templates.
* [1.0] Somehow make it possible to enter ":t foo" at the REPL (can't be done now because each atom is evaluated separately)
* [1.0] Preserve whitespace to allow saving forms back to disk.
* [1.0] Refactorings at the REPL. Rename, extract function, add/remove parameter?
* [1.0] --watch flag for recompiling when the files in the project change?

## Code generation
* [1.X] LLVM backend
* [?] Emit #LINE macros in the generated C code?

## Libraries
* Make Vector generic
* Threading
* Glfw
* OpenGL
* Move SDL into its own module, implement 'App' in Carp.

## Documentation
* [0.4] Document all core functions
* [0.4] Write a guide to how the compiler internals work
* [0.4] Improve the Memory.md docs

## Ugliness
* [1.0] Would be nice if Info from deftypes propagated to the templates for source location of their member functions.

## Language Design Considerations
* How to handle heap allocated values? Box type with reference count?
* Fixed-size stack allocated arrays would be useful (also as members of structs)
* Macros in modules must be qualified right now, is that a good long-term solution or should there be a 'use' for dynamic code?
* Allow use of 'the' as a wrapper when defining a variable or function, i.e. (the (Fn [Int] Int) (defn [x] x))?
* Being able to use 'the' in function parameter declarations, i.e. (defn f [(the Int x)] x) to enforce a type?
* Distinguish immutable/mutable refs?
* Reintroduce the p-string patch but with support for embedded string literals?

## Notes
* Should depsForCopyFunc and depsForDeleteFunc really be needed in Array templates, they *should* instantiate automatically when used?
