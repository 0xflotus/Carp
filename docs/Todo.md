# Todo

## Critical Bugs
* Ensure 'Array.pop-back' is memory safe and shrinks the array properly.
* Can't define globals of with heap allocated types (String, structs, etc.)
* A program using references to arrays but nothing else produces invalid typedefs (see sum-functions for adding the elements of an array)
* Compiling a self recursing function (of type (Î» [] ()) at least) hangs the compiler.

## Ugliness
* Just entering '=' at the REPL leads to strange type error.
* The 'range' function is fully generic (for all 'a') but only compiles when 'a' is numeric type
* Remove unnecessary Array-functions and rewrite them in Carp?
* Create a proper .c file for the core library C functions. Or at least rename the prelude.h file to core.h
* No need to set unique identifiers on XObj:s in Parse.hs?

## Big Language Features
* Allow evaluation of dynamic functions in the REPL and give access to the Commands from dynamic code
* Platform defines and optional compilation
* Generic data types (apart from Array, which already is)
* Tagged unions (also known as "sum types" or "enums")
* Lambdas (anonymous functions)
* Doc strings

## Smaller Language Features ("niceties")
* Good string functions
* Being able to use 'the' in function parameter declarations, i.e. (defn f [(the Int x)] x) to enforce a type
* Allow use of 'the' as a wrapper when defining a variable or function, i.e. (the (Fn [Int] Int) (defn [x] x))
* Quasiquote
* Splicing in macros
* Pattern matching on arguments in macros?
* Some lists and similar things generated by built in dynamic functions like 'cons' etc don't create proper Info for their XObjs
* A way to assert compiler errors in tests
* Load paths for (load ...) command

## Language Design Considerations
* What's the correct type of the variable in a set!-form, i.e. (set! &x value) or (set! x value)
* Is some kind of interface/typeclass construct worthwhile?
* How should passing primitive types (that do not care about being referenced) as ref:ed parameters be handled?
* How to handle heap allocated values? Box type with reference count?
* Fixed-size stack allocated arrays would be useful (also as members of structs)
* Look over how many times the function 'annotateOne' in Infer.hs actually needs to be applied to a form
* Macros in modules must be qualified right now, is that a good long-term solution?
* Should macros calling non-macros/non-dynamicfunctions just fail instead of returning an unvealuated list which is pretty confusing?
* Make @ work for all types, not just the 'use':d ones

## Code generation
* LLVM backend
* Emit #LINE macros in the generated C code

## Tooling
* Warning when changing the type of a function (can create bugs by overriding earlier declarations with the same name)
* Enable printing of typed AST:s at the REPL to help debug unresolved type variables etc.
* Proper error handling when defining invalid struct types (right now it crashes)
* Stop evalutaion of forms after errors to avoid "Trying to refer to undefined symbol" error
* Preserve whitespace to allow saving forms back to disk
* Refactorings at the REPL. Rename, extract function, add/remove parameter?
* Hide instances of templates/generic functions when printing the environment (by default, allow it as a setting)
* Somehow make it possible to enter ":t foo" at the REPL (can't be done now because each atom is evaluated separately)
* Rename type variables from t0, t1, t2 to a, b, c, etc.
* A way to run the compiler without entering the REPL, just build (and potentially run) all the code and then exit.
