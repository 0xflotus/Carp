(reset! echo-signature-after-bake true)
(reset! log-unloading-of-dylibs true)


(defn let-ref-bug []
  (copy (let [x [1 2 3]
              r &x]
          r)))



;; (defn arr-1 [x]
;;   [x 5])

;; (defn arr-2 [x]
;;   [x x])

;; (defn arr-3 [x]
;;   [(copy x) (copy x) (copy x)])

;; (defn arr-4 [x]
;;   [x x x x])

;; (defn arr-5 [x]
;;   [x x x x x])

;; (defn arr-6 [x]
;;   [x x x x x x])

;; (defn arr-10 [x]
;;   [x x x x x
;;    x x x x 5])

;; 8 + n * 6




;;(defn mk-arr-2 [] [[1] [2]])
;;(bake mk-arr-2)
;;(count (mk-arr-2))


;;(defstruct Foo [x :int])


;; (defn fold [f x xs]
;;   (do (for (i 0 (count xs))
;;         (reset! x (f &x (nth xs i))))
;;       x))

;; (defn add [x y]
;;   (+ (copy x) (copy y)))



;; (defn f [] (fold add 0 &[1 2 3]))

;; (defn f [i]
;;   (println (ref (str (copy i)))))

;; (defn f [i]
;;   (println (ref (itos (copy i)))))

;; ^ann '(:fn ((:ref :int)) :void)
;; (defn f [x]
;;   (println (str-ref (copy x))))

;; (defn draws [state]
;;   (domap f state))

;; (defn run-app [draw-fn]
;;   (let [state [10 20 30]]
;;     (draw-fn &state)))

;; (defn app []
;;   (run-app draws))










;; (defn h [a b]
;;   (+ (strlen a)
;;      (strlen b)))

;; (defn f []
;;   (h 3 "b"))

;; (defn g []
;;   (let [s (string-copy &"hej")]
;;     (f s)))

;;(bake g)

;; ^doc "Hej pÃ¥ dig"
;; ^ann '(:fn () :void)

;; (defn f [] "yeah")


;; (defn f []
;;   (let [a (fn [] (nth "erik"))
;;         b (fn [] (a))]
;;     (b)))

;; (defn aaa [x]
;;   (* x 10))

;; (defn bbb [f]
;;   (+ 1 (f 5)))

;; (bake bbb)

;; (println (str (bbb aaa)))

;; (defn servant [s]
;;   (string-append s "!"))

;; (defn master [f]
;;   (string-append (f "hje") "..."))

;; (bake master)

;; (println (master servant))


;;(when (not carp-dev) (load-lisp (str carp-dir "lisp/examples.carp")))
;;(defn tricky-let [] ((id id) 2))



;; (def CON {:a "t3", 
;;           :b :int, 
;;           :prio 20, 
;;           :location {:a {:line 11, 
;;                          :node :lookup, 
;;                          :original-form "strlen"}, 
;;                      :b {:line 11, 
;;                          :node :literal, 
;;                          :original-form "10"}}, 
;;           :constraint-kind :app-arg, 
;;           :arg-index 0, 
;;           :head-name "strlen", 
;;           :doc "app-arg t3 vs :int"})

;; (def CON2 {:a "t3"
;;            :b :BLORF
;;            :constraint-kind :whatevs})

;; (def CONS (list CON2 CON))

;; (defn test-CON []
;;   (solve-constraints CONS))













;; Creating structs with nested arr-2ay members, from the repl

;; (defstruct A [a :int])
;; (defstruct B [as (:Array :A)])
;; (println (str (B [(A 2) (A 3) (A 4)])))

;; (defstruct C [ass (:Array (:Array :A))])
;; ;;(println (ref (str (ref (C [[(A 2) (A 3) (A 4)] [(A 3) (A 4) (A 5)]])))))

;; (defstruct Blaj [blajArr (:Array :int)])
;; (defn f [] (str &(Blaj [1 2 3])))


;; (defstruct Blaj2 [blajArr2 (:Array (:Array :int))])
;; (defn g [] (str &(Blaj2 [[10 20 30] [40 50 60 70] [80 90]])))


;; (defstruct Blaj3 [blajArr3 (:Array (:Array (:Array :int)))])
;; (defn h [] (str &(Blaj3 [[[10 20 30] [40 50 60 70] [80 90]]
;;                          [[100 200 300] [400 500 600 700] [800 900]]])))
