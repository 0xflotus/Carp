(reset! echo-signature-after-bake true)
(reset! log-unloading-of-dylibs true)



(defn fold [f x xs]
  (do (for (i 0 (count xs))
        (reset! x (f &x (nth xs i))))
      x))

(defn add [x y]
  (+ (copy x) (copy y)))

(defn f [] (fold add 0 &[1 2 3]))





;; (defstruct B [b :bool])

;; (println (str (B true)))


;; (defn f [i]
;;   (println (ref (itos (copy i)))))

;; ^ann '(:fn ((:ref :int)) :void)
;; (defn f [x]
;;   (println (str-ref (copy x))))

;; (defn draws [state]
;;   (domap f state))

;; (defn run-app [draw-fn]
;;   (let [state [10 20 30]]
;;     (draw-fn &state)))

;; (defn app []
;;   (run-app draws))


(def CONSTRS (list
              
              {:a "x", 
               :b '(:BLURG :FLORP)}
              
              {:a '("y" "c"), 
               :b '(("a" "b") "a")}
              
              ))

;; (println (str "1:\n" (solve-constraints (cons-last CONSTRS {:a "x" :b "y"}))))
;; (println (str "\n2:\n" (solve-constraints (cons {:a "x" :b "y"} CONSTRS))))

;; (def answer
;;   (replace-subst-from-right 
;;    {"c" "a", 
;;     "x" '(:BLURG :FLORP), 
;;     "y" '("a" "b"), 
;;     "a" "a", 
;;     "b" "b"}
;;    "a"
;;    :BLURG
;;    ))


;; (defn h [a b]
;;   (+ (strlen a)
;;      (strlen b)))

;; (defn f []
;;   (h 3 "b"))

;; (defn g []
;;   (let [s (string-copy &"hej")]
;;     (f s)))

;;(bake g)

;; ^doc "Hej p√• dig"
;; ^ann '(:fn () :void)

;; (defn f [] "yeah")


;; (defn f []
;;   (let [a (fn [] (nth "erik"))
;;         b (fn [] (a))]
;;     (b)))

;; (defn aaa [x]
;;   (* x 10))

;; (defn bbb [f]
;;   (+ 1 (f 5)))

;; (bake bbb)

;; (println (str (bbb aaa)))

;; (defn servant [s]
;;   (string-append s "!"))

;; (defn master [f]
;;   (string-append (f "hje") "..."))

;; (bake master)

;; (println (master servant))


;;(when (not carp-dev) (load-lisp (str carp-dir "lisp/examples.carp")))
;;(defn tricky-let [] ((id id) 2))
