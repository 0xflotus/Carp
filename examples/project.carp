(reset! echo-signature-after-bake true)
(reset! log-unloading-of-dylibs true)




(defn join-many []
  (join "," (map str (range 1 100))))



(defn OLD-join (separator xs)
  (match (count xs)
    0 ""
    1 (str (first xs))
    _ (str (first xs) separator (join separator (rest xs)))))



;; (defn fold [f x xs]
;;   (do (for (i 0 (count xs))
;;         (reset! x (f &x (nth xs i))))
;;       x))

;; (defn add [x y]
;;   (+ (copy x) (copy y)))










;; (defn f [] (fold add 0 &[1 2 3]))

;; (defn f [i]
;;   (println (ref (str (copy i)))))

;; (defn f [i]
;;   (println (ref (itos (copy i)))))

;; ^ann '(:fn ((:ref :int)) :void)
;; (defn f [x]
;;   (println (str-ref (copy x))))

;; (defn draws [state]
;;   (domap f state))

;; (defn run-app [draw-fn]
;;   (let [state [10 20 30]]
;;     (draw-fn &state)))

;; (defn app []
;;   (run-app draws))










;; (defn h [a b]
;;   (+ (strlen a)
;;      (strlen b)))

;; (defn f []
;;   (h 3 "b"))

;; (defn g []
;;   (let [s (string-copy &"hej")]
;;     (f s)))

;;(bake g)

;; ^doc "Hej p√• dig"
;; ^ann '(:fn () :void)

;; (defn f [] "yeah")


;; (defn f []
;;   (let [a (fn [] (nth "erik"))
;;         b (fn [] (a))]
;;     (b)))

;; (defn aaa [x]
;;   (* x 10))

;; (defn bbb [f]
;;   (+ 1 (f 5)))

;; (bake bbb)

;; (println (str (bbb aaa)))

;; (defn servant [s]
;;   (string-append s "!"))

;; (defn master [f]
;;   (string-append (f "hje") "..."))

;; (bake master)

;; (println (master servant))


;;(when (not carp-dev) (load-lisp (str carp-dir "lisp/examples.carp")))
;;(defn tricky-let [] ((id id) 2))



;; (def CON {:a "t3", 
;;           :b :int, 
;;           :prio 20, 
;;           :location {:a {:line 11, 
;;                          :node :lookup, 
;;                          :original-form "strlen"}, 
;;                      :b {:line 11, 
;;                          :node :literal, 
;;                          :original-form "10"}}, 
;;           :constraint-kind :app-arg, 
;;           :arg-index 0, 
;;           :head-name "strlen", 
;;           :doc "app-arg t3 vs :int"})

;; (def CON2 {:a "t3"
;;            :b :BLORF
;;            :constraint-kind :whatevs})

;; (def CONS (list CON2 CON))

;; (defn test-CON []
;;   (solve-constraints CONS))
