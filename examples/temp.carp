;;(Debug.sanitize-addresses)
(Project.config "print-ast" true)

;; ;;(deftype Flip (A [String]) (B [Float]))

;; ;; (defn f []
;; ;;   (Flip.A 123))

;; ;; (defn g []
;; ;;   (Flip.B true 5.0f))

;; ;; (defn m []
;; ;;   (Maybe.Just 123))

;; ;; (defn n []
;; ;;   (the (Maybe Int) (Maybe.Nothing)))

;; ;; (defn main []
;; ;;   (let-do [x (Maybe.Just 100)
;; ;;            ;;y (the (Maybe Int) (Maybe.Nothing))
;; ;;            ]
;; ;;     (match x
;; ;;       ;;(Just a) (println* a)
;; ;;       (Maybe.Just a) (println* "a?")
;; ;;       (Maybe.Nothing) (println* "Nada!")
;; ;;       )))

;; (deftype Switch
;;   (Aha [Int])
;;   (Boo [Bool]))

;; ;; - The easy case -
;; ;; (defn main []
;; ;;   (match (Switch.Aha 42)
;; ;;     (Switch.Aha x) (println* (* x 2))
;; ;;     (Switch.Boo b) (println* (if b "YES" "NO"))))

;; ;; - More tricky -
;; (defn f [s]
;;   (match s
;;     (Switch.Aha x) (let [crap @"CRAP"]
;;                      (Int.str (* 2 x)))
;;     (Switch.Boo b) (if b @"YES" @"NO")
;;     (Switch.Boo blah) @"bleh"
;;     ))

;; ;; - Generic types -
;; (defn g [s]
;;   (match s
;;     (Maybe.Nothing) -1
;;     (Maybe.Just x)  x
;;     ))

;; ;; - More general -
;; (defn h [s d]
;;   (match s
;;     (Maybe.Nothing) d
;;     (Maybe.Just x)  x
;;     ))

;; ;; ;; - Fall through when passing Just
;; ;; (defn incomplete [s]
;; ;;   (match s
;; ;;     (Maybe.Nothing) 0
;; ;;     ))

;; ;; - Memory management, pt 1 -
;; (deftype People
;;   (One [String])
;;   (Two [String String]))

;; (defn m [p]
;;   (match p
;;     (People.One a) a
;;     (People.Two b c) b ;; pick the first one, the second one should be deleted
;;     ))

;; ;; ;; just a variation on the theme... all the variables a,b,c should be freed since they're not used
;; ;; (defn n [p]
;; ;;   (match p
;; ;;     (People.One a) 10
;; ;;     (People.Two b c) 20
;; ;;     ))

;; ;; ;; Using match as an if-then-else
;; ;; (defn ifthen [p]
;; ;;   (let [mem @"memory"]
;; ;;     (match p
;; ;;       (People.One a)   mem
;; ;;       (People.Two b c) @"no-memory"
;; ;;       )))

;; ;; Lets think this through...
;; ;; (deftype Q
;; ;;     (A [String])
;; ;;     (B [String String])
;; ;;     (C [String String String]))

;; ;; (defn memory-stuff [q]
;; ;;   (let [m1 @"m1"
;; ;;         m2 @"m2"
;; ;;         m3 @"m3"]
;; ;;     (match (the Q q)
;; ;;       ;; m3 needs to be deleted in this case
;; ;;       (Q.A a1)       m1
;; ;;       ;; m1 and m3 all needs to be deleted
;; ;;       (Q.B b1 b2)    @"other"
;; ;;       ;; m2 needs to be deleted (automatically) now
;; ;;       (Q.C c1 c2 c3) (do (String.delete m1)
;; ;;                          (String.delete m3)
;; ;;                          c1)
;; ;;       )))

;; (defn-do main []
;;   (println* &(f (Switch.Aha 123)))
;;   (println* &(f (Switch.Boo true)))
;;   (println* &(f (Switch.Boo false)))

;;   (println* &(g (Maybe.Just 666)))
;;   (println* &(g (Maybe.Nothing)))

;;   ;;(println* &(incomplete (the (Maybe Int) (Maybe.Nothing))))
;;   ;;(println* &(incomplete (Maybe.Just 12345)))

;;   (println* &(m (People.One @"Adam")))
;;   (println* &(m (People.Two @"Eve" @"Adam")))
;;   )

;; (deftype Commands
;;   StandGround
;;   Fire
;;   Retreat)

;; (deftype Elements
;;   Water
;;   Fire ;; <- name clash!
;;   Earth
;;   Air)

;; (use Commands)
;; (use Elements)

;; (defn f [] (Water))

;; (defn figure-out-sumtype [x]
;;   (match x
;;     Fire (Water)
;;     Air (Earth)))

;; (use Maybe)

;; (defn g [x]
;;   (match x
;;     (Just a) a
;;     (Nothing) -1))

;; (defn main []
;;   (do
;;     (println* &(Just false))
;;     (println* &@&(Maybe.Just @"hello"))
;;     (println* &(figure-out-sumtype (Elements.Fire)))
;;     (println* (g (Just 123)))))

;; (use Maybe)

;; (defmodule Maybe

;;   (defn nothing? [x]
;;     (match x
;;       (Nothing) true
;;       (Just x)  false))

;;   (defn = [a b]
;;     (match a
;;       (Nothing) (nothing? b)
;;       (Just x) (match b
;;                  (Nothing) false
;;                  (Just y) (= x y))))

;;   )

;; (defn main []
;;   (println* (= (Just 10) (Nothing))))

(use Maybe)

(defn wildcard [x]
  (match x
    Nothing @"No"
    (x) @"Yes"
    ))

(deftype Name
  (Simple [String String])
  (Fancy [String String String]))

(use Name)

(defn wildcards-inside [name]
  (match name
    (Simple _ _) 1
    (Fancy _ _ _) 2))

(defn main []
  (println* (wildcard (Maybe.Just @""))))
