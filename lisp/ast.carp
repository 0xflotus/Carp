;; Anatomy of AST nodes
;; { :node = The kind of node this is. Can be :function / :arg / :literal / :app (function application) / :binop
;;   :type = The type that has been calculated for this node.
;;   :name = Used by AST nodes where this makes sense. The name of a variable or function, etc.
;; }

;; Anatomy of a type
;; Before the type is known it is set to a typevar which is a string of the form "t0", "t1", etc
;; Types can be just a keyword like :int / :string
;; Complex types are lists, like the :fn type (:fn (:int :int) :string) which corresponds to (Int, Int) -> String

(def typevar-counter 0)

(defn gen-typevar ()
  (let [typevar (str "t" typevar-counter)]
    (do (swap! typevar-counter inc)
        typevar)))

(defn arg-list-to-ast (args)
  (map (fn (arg)
         {:node :arg
          :name arg
          :type (gen-typevar)})
       args))

(defn binop? (form)
  (match form
         (x & _) (contains? '(+ - * / <) x)
         _ false))

(defn gen-fn-type (arg-count)
  (list :fn (repeatedly gen-typevar arg-count) (gen-typevar)))

(defn list-to-ast (l)
  (if (binop? l)
    (match l
           (op left right) {:node :binop
                     :type (gen-typevar)
                     :op op
                     :left (form-to-ast left)
                     :right (form-to-ast right)})
    (match l
           ('= left right) {:node :binop
                            :type :bool
                            :op '==
                            :left (form-to-ast left)
                            :right (form-to-ast right)}
           (x & xs) (if (and (symbol? x) (def? x) (macro? (eval x)))
                      (expand-macro l)
                      {:node :app
                       :type (gen-typevar)
                       :head (assoc (form-to-ast x) :type (gen-fn-type (count xs)))
                       :tail (map form-to-ast xs)})
           nil {:node :literal :type :any :value ""})))

(defn expand-macro (form)
  (do ;;(println (str "expand:\n" form))
      (let [macro (code (eval (first form)))
            mlam (eval (list 'fn (nth macro 1) (nth macro 2))) ;; convert macro to lambda... this is a strange way to do it
            ;;_ (println (str "macro-lambda: " mlam ", type: " (type mlam)))
            args (rest form)
            ;;_ (println (str "args: " args))
            called-macro (apply mlam args)
            ;;called-macro-forms (eval called-macro)
            expanded-ast (form-to-ast called-macro)
            ;;_ (println (str "expanded-ast: " expanded-ast))
            ]
        ;;(println (str "called-macro:\n" called-macro ", type: " (type called-macro)))
        expanded-ast)))

(defn if-to-ast (expr if-true if-false)
  {:node :if
   :type (gen-typevar)
   :expr (form-to-ast expr)
   :if-true (form-to-ast if-true)
   :if-false (form-to-ast if-false)})

(defn do-to-ast (forms)
  {:node :do
   :type (gen-typevar)
   :forms (map form-to-ast forms)})

(defn bindings-to-ast (bindings)
  (match bindings
    [name value & rest-bindings] (cons {:node :binding
                                        :type (gen-typevar)
                                        :name name
                                        :value (form-to-ast value)}
                                       (bindings-to-ast rest-bindings))
    _ ()))

(defn let-to-ast (bindings body)
  {:node :let
   :type (gen-typevar)
   :bindings (bindings-to-ast bindings)
   :body (form-to-ast body)})

(defn while-to-ast (expr body)
  {:node :while
   :type :void
   :expr (form-to-ast expr)
   :body (form-to-ast body)})

(defn ref-to-ast (expr)
  {:node :ref
   :type (list :ref (gen-typevar))
   :expr (form-to-ast expr)})

(defn reset-to-ast (symbol expr)
  (if (symbol? symbol)
    {:node :reset
     :type :void
     :symbol symbol
     :expr (form-to-ast expr)}
    (error (str "Non-symbol '" symbol "' found in reset! form."))))

(defn literal-or-lookup-to-ast (expr)
  (if (symbol? expr)
    {:node :lookup
     :type (gen-typevar)
     :value expr} ;; change key to :name ..?
    {:node :literal
     :type (let [t (type expr)] (if (= :string t) '(:ref :string) t)) ; Literal strings are refs
     :value expr}))

(defn form-to-ast (form)
  (match form
    
    ('if expr a b) (if-to-ast expr a b)
    ('if & _) (error (str "'if' needs exactly two branches. Compiler got:\n" form))

    ('do & forms) (do-to-ast forms)

    ('let bindings body) (let-to-ast bindings body)
    ('let & _) (error (str "'let' needs exactly two inner forms, bindings and a body. Compiler got:\n" form))

    ('while expr body) (while-to-ast expr body)
    ('while & _) (error (str "'while' needs exactly two inner forms, an expression and a body. Compiler got:\n" form))

    ('ref expr) (ref-to-ast expr)
    ('ref & _) (error (str "'ref' needs exactly one inner form, an expression. Compiler got:\n" form))

    ('reset! symbol expr) (reset-to-ast symbol expr)
    ('reset! & _) (error (str "'reset' needs exactly two inner form, a symbol and an expression. Compiler got:\n" form))
    
    ('include-c-code s) {:node :c-code :code s :type (gen-typevar)}
    'NULL {:node :null :type (gen-typevar)}
    'true {:node :literal :type :bool :value 1}
    'false {:node :literal :type :bool :value 0}
    x (if (= :list (type x))
        (list-to-ast x)
        (literal-or-lookup-to-ast x))
    ))

(defn body-to-ast (body)
  (form-to-ast body))

;; Takes a list representation of a lambda and creates an AST from it
(defn lambda-to-ast (form)
  (do (assert-eq :list (type form))
      (match form
             ('fn args body) {:node :function
                              :type (gen-fn-type (count args))
                              :args (arg-list-to-ast args)
                              :body (body-to-ast body)}
             _ (error (str "Failed to match lambda form: " form)))))
