(def slim-code-generation true)

;; Creates a C code builder which allows for out-of-order generation of C from the AST
(defn new-builder ()
  {:headers ()
   :functions ()})

(defn builder-add (builder category block)
  (update-in builder (list category) (fn (blocks) (cons-last blocks block))))

(defn builder-add-headers (builder files)
  (reduce (fn (b file) (builder-add b :headers (str "#include " file)))
          builder
          files))

(defn builder-add-main-function (builder func-name)
  (builder-add builder :functions (str "int main() { " func-name "(); }")))

;; Takes a completed C code builder and returns its string with C code
(defn builder-merge-to-c (builder)
  (let [funcs (get builder :functions)
        headers (get builder :headers)]
    (join "\n\n"
          (list (join "\n" headers)
                (join "\n" funcs)))))

(def indent-level 1)

(defn indent ()
  (join "" (replicate "  " indent-level)))

(defn indent-in! ()
  (swap! indent-level inc))

(defn indent-out! ()
  (swap! indent-level dec))

(defn free-variables (free-list)
  (join "" (map (fn (variable) (str (indent) "free(" (c-ify-name (:name variable)) ");\n")) free-list)))

(defn c-ify-name (lisp-name)
  (let [x0 (str-replace lisp-name "-" "_")
        x1 (str-replace x0 "?" "QMARK")
        x2 (str-replace x1 "!" "BANG")
        x3 (str-replace x2 "*" "PTR")]
    x3))

(defn ensure-function-type [t]
  (match t
    (:fn arg-types return-type) (let [func-type-name (str "Fn_" (join "_" (map type-build arg-types)) "_" (type-build return-type))]
                                  (do (if (has-key? types func-type-name)
                                        (do ;;(println (str "Ignoring " func-type-name))
                                            func-type-name)
                                        (do ;;(println (str "Adding function type " func-type-name))
                                            (add-type! func-type-name
                                                       (str "typedef " (type-build return-type) "(*" func-type-name ")(" (join "," (map type-build arg-types)) ");"))
                                            func-type-name))))

    _ (error "Can't match t in ensure-function-type: " t)))

(defn type-build (t)
  (if (string? t)
    ;;(error (str "Can't build type from unresolved typevar '" t "'"))
    "typevar"
    (match t
           :? "unknown"
           (:fn _ _) (ensure-function-type t)
           (:ref r) (type-build r)
           (:Array a) "Array*"
           :float "float"
           :int "int"
           :char "char"
           :bool "bool"
           :string "string"
           :void "void"
           x (str (c-ify-name (name x)) "*"))))

(defn visit-arg-explicit (c arg)
  (let [result (visit-form c arg true)]
    (str-append! c (str (indent) (type-build (:type arg)) " " (:arg-name arg) " = " (get result :c) ";\n"))))

(defn visit-args-explicit (c args)
  (let []
    (do
      ;;(println "visit args:" args)
      (map (fn (arg) (visit-arg-explicit c arg)) args)
      (map (fn (arg) {:c (:arg-name arg)}) args))))


(defn inlined-literal? (ast)
  (and (= :literal (:node ast))
       (contains? '(:int :float :bool (:ref :string)) (:type ast))))

(defn inlined-lookup? (ast)
  (= :lookup (:node ast)))

(defn inlined-binop? (ast)
  (= :binop (:node ast)))

;; Print Objs in a way that the C compiler accepts
(defn c-prn (x)
  (match (type x)
    :char (str "'" x "'") ;; chars are written like this in Carp: \e but like this: 'e' in C.
    _ (prn x)))

;; New version of visit arg that generates slimmer code (no intermediate arg variables)
(defn visit-arg-slim (c arg)
  (let [arg-name (:arg-name arg)
        arg-type (:type arg)
        result (visit-form c arg true)]
    (match (:node arg)

      :lookup (do ;;(println (str "Arg " arg-name " is lookup."))
                  {:c (c-ify-name (str (:value arg)))})

      :literal (do ;;(println (str "Arg " arg-name " is literal."))
                   {:c (c-prn (:value arg))})

      _ (let [result-name (get-maybe arg :result-name)]
          (if (nil? result-name)
            (do (str-append! c (str (indent) (type-build arg-type) " " arg-name " = " (:c result) ";\n"))
                {:c (:arg-name arg)})
            {:c result-name}))

      )))

(defn visit-args-slim (c args)
  (let []
    (do
      ;(println (str "visit args slim:\n" args))
      (map (fn (arg) (visit-arg-slim c arg)) args))))

(defn visit-let-bindings (c bindings)
  (map (fn (b) (let [value-result (visit-form c (:value b) false)]
                 (str-append! c (str (indent) (type-build (:type b)) " " (c-ify-name (str (:name b))) " = " (:c value-result) ";\n"))))
       bindings))

(defn visit-form (c form toplevel)
  (do
    ;;(println (str "\nvisit-form:\n" form))
    (match (get form :node)

           :binop (let [result-a (visit-form c (get form :left) false)
                        result-b (visit-form c (get form :right) false)]
                    {:c (str (if toplevel "" "(") (:c result-a) " " (:op form) " " (:c result-b) (if toplevel "" ")"))})

           :literal (let [val (:value form)
                          result-name (get-maybe form :result-name)]
                      (if (or (inlined-literal? form) (nil? result-name))
                        {:c (c-prn val)}
                        (do
                          (str-append! c (str (indent)
                                              (type-build (:type form)) " "
                                              (:result-name form) " = "
                                              (c-prn val) ";\n"))
                          {:c (:result-name form)})))
           
           :lookup (let [val (:value form)]
                     {:c (c-ify-name (name val))})

           :ref (let [expr (:expr form)
                      result (visit-form c expr toplevel)]
                  result)

           :reset (let [expr (:expr form)
                        symbol (:symbol form)
                        result (visit-form c expr toplevel)]
                    (do (str-append! c (str (indent) symbol " = " (:c result) ";\n"))
                        {:c ""}))

           :if (let [n (get form :result-name)
                     if-expr (visit-form c (get form :expr) true)]
                 (do (if (= :void (:type form))
                       () ;; no result variable needed
                       (str-append! c (str (indent) (type-build (:type form)) " " n ";\n")))
                     
                     (str-append! c (str (indent) "if("))
                     (str-append! c (:c if-expr))
                     (str-append! c (str ")"))
                     
                     ;; true-block begins
                     (str-append! c " {\n")
                     (indent-in!)
                     (let [result-a (visit-form c (:if-true form) true)]
                       (do
                         (str-append! c (free-variables (get-maybe form :free-left)))
                         (if (= :void (:type form))
                           () ;; no-op
                           (str-append! c (str (indent) n " = " (get result-a :c) ";\n")))
                         (indent-out!)
                         (str-append! c (str (indent) "} else {\n"))))
                     
                     (indent-in!) ;; false-block-begins
                     (let [result-b (visit-form c (:if-false form) true)]
                       (do
                         (str-append! c (free-variables (get-maybe form :free-right)))
                         (if (= :void (:type form))
                           () ;; no-op
                           (str-append! c (str (indent) n " = " (get result-b :c) ";\n")))
                         (indent-out!)
                         (str-append! c (str (indent) "}\n"))))
                     {:c n}))
           
           :app (let [head (get form :head)
                      func-name (get head :value)
                      c-func-name (c-ify-name (str func-name))
                      n (:result-name form)
                      ;;_ (println (str "c before call to " func-name ":\n" c))
                      arg-results ((if slim-code-generation visit-args-slim visit-args-explicit) c (get form :tail))
                      ;;_ (println (str "c after call to " func-name ":\n" c))
                      arg-vars (map :c arg-results)
                      t (:type form)]
                  (do
                    (when (= true (get-maybe head :constructor))
                      (build-constructor form))
                    (if (= :void t)
                      (do (str-append! c (str (indent) c-func-name "(" (join ", " arg-vars) ");\n"))
                          {:c n})
                      ;;{:c (str c-func-name "(" (join ", " arg-vars) ")")}
                      (do (str-append! c (str (indent) (type-build t) " " n " = " c-func-name "(" (join ", " arg-vars) ");\n"))
                          {:c n})
                      )))

           :do (let [forms (:forms form)
                     ;_ (println (str "forms:\n" forms))
                     results (map (fn (x) (visit-form c x toplevel)) forms)]
                 {:c (:c (last results))})

           :let (let [n (:result-name form)]
                  (do (if (= :void (:type form))
                        () ;; nothing
                        (str-append! c (str (indent) (type-build (:type form)) " " n ";\n")))
                      (str-append! c (str (indent) "{\n"))
                      (indent-in!)
                      (let [body (:body form)
                            _ (visit-let-bindings c (:bindings form))
                            result (visit-form c body false)]
                        (do (str-append! c (free-variables (get-maybe form :free)))
                            (if (= :void (:type form))
                              ()
                              (str-append! c (str (indent) n " = " (:c result) ";\n")))))
                      (indent-out!)
                      (str-append! c  (str (indent) "}\n"))
                      {:c n}))

           :while (let [while-expr (visit-form c (get form :expr) true)
                        while-expr-name (:while-expr-name form)]
                    (do (str-append! c (str (indent) (type-build (get-in form '(:expr :type))) " " while-expr-name " = " (get while-expr :c) ";\n"))
                        (str-append! c (str (indent) "while(" while-expr-name ") {\n"))
                        (indent-in!)
                        (let [body (:body form)]
                          (visit-form c body false))
                        (let [while-expr-again (visit-form c (get form :expr) true)]
                          (do
                            (str-append! c (free-variables (get-maybe form :free)))
                            (str-append! c (str (indent) while-expr-name " = " (get while-expr-again :c) ";\n"))
                            ))
                        (indent-out!)
                        (str-append! c  (str (indent) "}\n"))))

           :c-code (do
                     ;;(str-append! c )
                     {:c (:code form)})

           :null {:c "NULL"}
           
           x (error (str "visit-form failed to match " x)))))

(defn arg-list-build (args)
  (join ", " (map (fn (arg) (str (type-build (get arg :type)) " " (get arg :name)))args)))

(defn visit-function (builder ast func-name)
  (let [t (:type ast)
        _ (when (not (list? t)) (error "Can't generate code for function, it's type is not a list."))
        return-type (nth t 2)
        args (get ast :args)
        body (get ast :body)
        c (copy "") ;; mutable string holding the resulting C code for the function
        result (visit-form c body true)
        result-var-name (:result-name ast)
        ret-type (get-in ast '(:type 2))]
    (do
      ;;(println "visit-function: \n" ast)
      (let [code (str "API " (type-build return-type) " " (c-ify-name func-name)
                      "(" (arg-list-build args) ") {\n"
                      c
                      (if (= :void ret-type)
                        ""
                        (str (indent) (type-build ret-type) " " result-var-name " = " (get result :c) ";\n")) ;; TODO: evaluate if this extra step is needed
                      (free-variables (get-maybe ast :free))
                      (if (= :void (:type body))
                        "" ;; no return
                        (str (indent) "return " result-var-name ";\n"))
                      "}")]
        (builder-add builder :functions code)))))

;; This should potentially be done in a separate pass but right now I put it here.
;; What's needed when generating the code for structs is all the types used when
;; calling the constructor. Trying to do it in the 'generics' pass is hard since
;; we have too little information there.
(defn build-constructor [app-ast]
  (let [;;_ (println (str app-ast))
        constructor-ast (:head app-ast)
        _ (assert-eq true (:constructor constructor-ast))
        member-names (array-to-list (:member-names constructor-ast))
        member-types (array-to-list (:member-types constructor-ast))
        struct-name (:struct-name constructor-ast)
        constructor-name (str "new-" struct-name)
        c-constructor-name (c-ify-name constructor-name)
        c-file-name (str out-dir constructor-name ".c")
        constructor-signature (list :fn member-types (keyword constructor-name))
        ;;_ (println (str constructor-signature))
        ]
    (if (func-baked? constructor-name)
      (do
        ;;(println (str "Ignoring already baked constructor '" constructor-name "'"))
        nil)
      (let [type-def-c (join " " (map2 (fn [t n] (str (type-build t) " " n ";")) member-types member-names))
            type-definition (str "typedef struct { " type-def-c " } " struct-name ";")
            arg-list-c (join ", " (map2 (fn [t n] (str (type-build t) " " n)) member-types member-names))
            proto (str struct-name " *" c-constructor-name "(" arg-list-c ");")
            substs {"STRUCT-NAME" struct-name
                    "CONSTRUCTOR-NAME" c-constructor-name
                    "ARG_LIST" arg-list-c
                    "SETTERS" (join "\n  " (map (fn [n] (str "new_struct->" n " = " n ";")) member-names))}
            c-program-string (template
"#include \"functions.h\"\n\nAPI STRUCT-NAME *CONSTRUCTOR-NAME(ARG_LIST) {
  STRUCT-NAME *new_struct = malloc(sizeof(STRUCT-NAME));
  SETTERS
  return new_struct;
}"
                                       substs)
            deps '()
            ]
        (do
          (add-type! constructor-name type-definition)
          (def c c-program-string)
          (save-and-compile constructor-name constructor-signature c-constructor-name c-file-name c-program-string proto deps false)
          )))))

(defn get-function-prototype (ast func-name)
  (let [t (get ast :type)
        return-type (nth t 2)
        args (get ast :args)]
    (str "API " (type-build return-type) " " (c-ify-name func-name) "(" (arg-list-build args) ");")))

(defn builder-visit-ast (builder ast func-name)
  (match (get ast :node)
         :function (visit-function builder ast func-name)
         x (error (str "Can't match :ast '" x "' in builder-visit-ast."))))
