
(defn convert-param-node (a)
  {:name (str (:name a))
   :type (:type a)})

(defn convert-arg-node (a)
  {:name (str (:arg-name a))
   :type (:type a)})

(defn managed-type? (t)
  (match t
         (:ref x) (managed-type? x)
         _ (= t :string)))

(defn manage? (descriptor)
  (managed-type? (:type descriptor)))

(defn dont-free-result-variable (ast vars)
  (let [result-var-name (get-maybe ast :result-name)]
    (do
      ;;(println (str "result-var-name: " result-var-name))
      (if (= nil result-var-name)
        vars
        (remove (fn (v) (= (:name v) result-var-name)) vars)))))

(defn ref? (v)
  (do
    ;;(println (str "ref? " v))
    (match v
           (:ref _) true
           _ false)))

(defn remove-vars-with-names (vars names)
  (do
    ;;(println (str "remove vars from " vars " with names " names))
    (remove (fn (v) (and
                     (not (ref? (:type v)))
                     (contains? names (:name v)))) vars)))

(defn calculate-lifetimes-internal (data)
  (do
    ;;(println (str "CALC:\n" data))
    (let [ast (:ast data)
          vars (:vars data)]
      (match (:node ast)

             :function (let [parameter-nodes (:args ast)
                             new-variables (filter manage? (map convert-param-node parameter-nodes))
                             ;;_ (println (str ":function new-variables: " new-variables))
                             data-after (calculate-lifetimes-internal {:ast (:body ast) :vars new-variables})
                             vars-after (:vars data-after)
                             vars-with-return-value-removed (dont-free-result-variable (:body ast) vars-after)]
                         {:ast (assoc ast :free vars-with-return-value-removed)
                          :vars '()})

             :literal {:ast ast
                       :vars (cons {:name (:result-name ast) :type (:type ast)} vars)}

             :app (let [tail (:tail ast)
                        arg-names (map (fn (a) (str (:value a))) (filter (fn (a) (= (:node a) :lookup)) tail))
                        ;;_ (println (str "vars: " vars "\narg names: " arg-names))
                        vars-after (remove-vars-with-names vars arg-names)]
                    (do
                      ;;(println (str "APP\n" arg-names "\nVARS AFTER\n" (remove-vars-with-names vars arg-names)))
                      {:ast ast
                       :vars vars-after}))
             
             _ data))))

(defn calculate-lifetimes (ast)
  (:ast (calculate-lifetimes-internal {:ast ast
                                       :vars '()})))





;; :function (let [arg-nodes (:args ast)
;;                            variables (filter manage? (map convert-param-node arg-nodes))
;;                            data-after (calculate-lifetimes-internal {:ast (:body ast)
;;                                                                      :vars variables})]
;;                        {:ast (assoc ast :free (:vars data-after))
;;                         :vars '()})

;;            ;; :literal (if (heap-allocated? ast)
;;            ;;            (let [new-vars (cons (:literal-name ast) vars)]
;;            ;;              {:ast ast
;;            ;;               :vars new-vars})
;;            ;;            data)

;;            :app (let [tail (:tail ast)
;;                       ;;_ (println (str "Tail:\n" tail))
;;                       new-vars (concat (map convert-arg-node (filter manage? tail)) vars)
;;                       ;;_ (println (str "new-vars: " new-vars))
;;                       ]
;;                   {:ast ast
;;                    :vars new-vars})

;;            :binop (let [left (:a ast)
;;                         right (:b ast)
;;                         data-left (calculate-lifetimes-internal {:ast left :vars vars})
;;                         data-right (calculate-lifetimes-internal {:ast right :vars vars})
;;                         new-vars (union (:vars data-left) (:vars data-right))]
;;                     {:ast ast ;; <- TODO: fix, should visit the left and right ast and assoc them in
;;                      :vars new-vars})
