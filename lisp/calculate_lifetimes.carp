
(defn convert-param-node (a)
  {:name (str (:name a))
   :type (:type a)
   :doc "parameter"})

(defn primitive-type? (t)
  (contains? '(:int :float :bool) t))

(defn void-type? (t)
  (= :void t))

(defn managed-type? (t)
  (match t
    (:ref x) false
    _ (not (or (void-type? t) (primitive-type? t)))))

(defn manage? (descriptor)
  (managed-type? (:type descriptor)))

(defn dont-free-result-variable (ast vars)
  (let [result-var-name (get-maybe ast :result-name)]
    (do
      ;;(println (str "result-var-name: " result-var-name))
      (if (= nil result-var-name)
        vars
        (remove (fn (v) (= (:name v) result-var-name)) vars)))))

(defn ref? (v)
  (match v
    (:ref _) true
    _ false))

(defn remove-var-with-name (vars name)
  (remove (fn (v) (= name (:name v))) vars))

;; Used for reducing over the args in a function application
(defn calc-lifetime-for-arg (data parameter-types arg-ast)
  (do
    ;;(println "CALCARG. data:\n")
    ;;(println (str data "\n"))
    ;;(println "arg-ast:\n")
    ;;(println arg-ast)
    (let [ast (:ast data)
          vars (:vars data)
          pos (:pos data)
          parameter-type (nth parameter-types pos)
          is-ref (ref? parameter-type)

          ;;_ (println (str "\n " (:arg-name arg-ast) " vars:\n" vars "\n"))
          
          new-data (if (and (= :literal (:node arg-ast)) (not is-ref))
                     {:ast arg-ast :vars vars} ;; a literal as an arg to a non-ref parameter doesn't create any new vars to free
                     (calculate-lifetimes-internal {:ast arg-ast
                                                    :vars vars}
                                                   is-ref))
          new-arg-ast (:ast new-data)
          new-vars (:vars new-data)

          ;;_ (println (str "\nnew-vars:\n" new-vars "\n"))

          new-vars-eaten-result (let [result-name (get-maybe new-arg-ast :result-name)]
                                  (if (nil? result-name)
                                    new-vars
                                    (remove-var-with-name new-vars result-name)))

          ;;_ (println (str "\nnew-vars-eaten-result:\n" new-vars-eaten-result "\n"))
          
          ;;_ (println (str "new-arg-ast:\n" new-arg-ast))
          
          new-ast (assoc-in ast (list :tail pos) new-arg-ast)

          ;;_ (println (str "pos " pos " AST: " ast " => " new-ast))
          
          new-app-data {:ast new-ast
                        :vars new-vars-eaten-result
                        :pos (inc pos)}]
      new-app-data)))

(defn calc-lifetime-for-let-binding (data binding-ast)
  (do
    (let [ast (:ast data)
          vars (:vars data)
          pos (:pos data)

          extended-vars (let [t (:type binding-ast)]
                          (do
                            ;;(println (str "is " (:name binding-ast) " : " t " a managed type? " (managed-type? t)))
                            (if (managed-type? t)
                              (cons {:name (str (:name binding-ast)) :type t :doc "let binding"} vars)
                              vars)))

          ;;_ (println (str "\nextended-vars: " extended-vars))
          
          new-data (calculate-lifetimes-internal {:ast (:value binding-ast) :vars extended-vars} false)
          new-binding-ast (assoc binding-ast :value (:ast new-data))
          new-vars (:vars new-data)

          ;;_ (println (str "\nnew-vars:\n" new-vars))

          new-vars-after-handover (let [result-name (get-maybe (:value binding-ast) :result-name)]
                                    (if (nil? result-name)
                                      new-vars
                                      (remove-var-with-name new-vars result-name)))

          ;;_ (println (str "\nnew-vars-after-handover:\n" new-vars-after-handover))

          new-ast (assoc-in ast (list :bindings pos) new-binding-ast)
          ;;_ (println (str "pos " pos " AST: " ast "\n => \n" new-ast))
          
          new-app-data {:ast new-ast
                        :vars new-vars-after-handover
                        :pos (inc pos)}]
      new-app-data)))

(defn calc-lifetime-for-do-form (data form-ast)
  (do
    (let [ast (:ast data)
          vars (:vars data)
          pos (:pos data)
          eaten (get-maybe data :eaten)

          data-after-visited-form (calculate-lifetimes-internal {:ast form-ast
                                                                 :vars vars
                                                                 :eaten eaten} false)
          
          vars-after-visited-form (:vars data-after-visited-form)
          form-ast-after-visited-form  (:ast  data-after-visited-form)

          new-ast (assoc-in ast (list :forms pos) form-ast-after-visited-form)
          new-eaten (get-maybe data-after-visited-form :eaten)
          
          new-app-data {:ast new-ast
                        :vars vars-after-visited-form
                        :pos (inc pos)
                        :eaten new-eaten}]
      new-app-data)))

(defn calculate-lifetimes-internal (data in-ref)
  (do
    ;;(println (str "CALC: " (:node (:ast data))))
    (let [ast (:ast data)
          vars (:vars data)]
      (match (:node ast)

        :function (let [parameter-nodes (:args ast)
                        new-variables (filter manage? (map convert-param-node parameter-nodes))
                        ;;_ (println (str ":function new-variables: " new-variables))
                        pre-body (:body ast)
                        ;;_ (println (str "\npre-body:\n" pre-body))
                        data-after (calculate-lifetimes-internal {:ast pre-body :vars new-variables} in-ref)
                        vars-after (:vars data-after)
                        vars-with-return-value-removed (dont-free-result-variable (:body ast) vars-after)
                        new-body (:ast data-after)

                        ;;_ (println (str "\nnew-body:\n" new-body))
                        ;;_ (println (str "\nast before:\n" ast))
                        ast-after (assoc ast :body new-body)
                        ;;_ (println (str "\nast after:\n" ast-after))
                        ast-final (assoc ast-after :free vars-with-return-value-removed)
                        ;;_ (println (str "\nast final:\n" ast-final))
                        ]
                    {:ast ast-final
                     :vars '()})

        :literal (let [vars-after (if (managed-type? (:type ast))
                                    (cons {:name (:result-name ast) :type (:type ast) :doc "literal"} vars)
                                    vars)
                       ;;_ (println (str "vars-after literal " (:value ast) ": " vars-after))
                       ]
                   {:ast ast
                    :vars vars-after})

        :ref (let [data-after (calculate-lifetimes-internal {:ast (:expr ast) :vars vars} in-ref)]
               {:ast (assoc ast :expr (:ast data-after))
                :vars (:vars data-after)})

        :lookup (let [;;_ (println (str "in-ref: " in-ref ", lookup: " ast))
                      vars-after (if in-ref ;;(ref? (:type ast))
                                   vars
                                   (remove-var-with-name vars (str (:value ast))))
                      
                      ;; _ (when (not (= vars vars-after))
                      ;;     (do (println (str "\nLookup ate '" (:value ast) "':\n" ast))
                      ;;         ;;(println (str "Vars before:\n" vars "\nVars after:\n" (:value ast) ": " vars-after))
                      ;;         ))
                      
                      final-ast {:ast ast
                                 :vars vars-after}

                      ;;_ (println (str "final-ast:\n" final-ast))
                      ]
                  final-ast)

        :binop (let [left (calculate-lifetimes-internal {:ast (:a ast) :vars vars} in-ref)
                     vars-after-left (:vars left)
                     right (calculate-lifetimes-internal {:ast (:b ast) :vars vars-after-left} in-ref)
                     vars-after-right (:vars right)
                     ast0 (assoc ast :a (:ast left))
                     ast1 (assoc ast0 :b (:ast right))]
                 {:ast ast1
                  :vars vars-after-right})

        :app (let [;;_ (println (str "APP VARS BEFORE\n" vars))
                   tail (:tail ast)
                   init-data (assoc data :pos 0)
                   parameter-types (get-in ast '(:head :type 1))
                   data-after (reduce (fn (d a) (calc-lifetime-for-arg d parameter-types a)) init-data tail)
                   vars-after (:vars data-after)
                   ret-type (get-in ast '(:head :type 2))
                   vars-after-with-ret-val (if (managed-type? ret-type)
                                             (cons {:name (:result-name ast) :type ret-type :doc "app ret val"} vars-after)
                                             vars-after)
                   ast-after (:ast data-after)]
               (do
                 ;;(println (str "APP VARS AFTER\n" vars-after))
                 {:ast ast-after
                  :vars vars-after-with-ret-val}))

        :if (let [;;_ (println (str "if-ast:\n" ast))
                  data-after-expr (calculate-lifetimes-internal {:ast (:expr ast) :vars vars} in-ref)

                  vars-after-expr (:vars data-after-expr)
                  data-after-left  (calculate-lifetimes-internal {:ast (:a ast) :vars vars-after-expr} in-ref)
                  data-after-right (calculate-lifetimes-internal {:ast (:b ast) :vars vars-after-expr} in-ref)
                  ;;_ (println (str "data-after-left:\n" data-after-left "\ndata-after-right:\n" data-after-right))

                  vars-after-left  (let [result-name (get-maybe (:a ast) :result-name)
                                         vs (:vars data-after-left)]
                                     (if (nil? result-name)
                                       vs
                                       (remove-var-with-name vs result-name)))
                  
                  vars-after-right (let [result-name (get-maybe (:b ast) :result-name)
                                         vs (:vars data-after-right)]
                                     (if (nil? result-name)
                                       vs
                                       (remove-var-with-name vs result-name)))

                  new-vars-left  (remove (fn (v) (contains? vars-after-expr v)) vars-after-left) ;; the NEW vars after visiting this branch
                  new-vars-right (remove (fn (v) (contains? vars-after-expr v)) vars-after-right)

                  ;;_ (println (str "vars-after-left:\n" vars-after-left "\nvars-after-right:\n" vars-after-right))

                  vars-after-all (intersection vars-after-left vars-after-right)
                  vars-removed (filter (fn (v) (contains? vars-after-expr v)) vars-after-expr) ;; vars "eaten" by either the left or right branch

                  ;;_ (println (str "vars removed:\n" vars-removed))
                  
                  free-left  (concat new-vars-left
                                     (remove (fn (v) (contains? vars-after-right v)) vars-removed))
                  free-right (concat new-vars-right
                                     (remove (fn (v) (contains? vars-after-left  v)) vars-removed))

                  ;;_ (println (str "free-left:\n" free-left "\nfree-right:\n" free-right))
                  
                  ast-after-expr (assoc ast :expr (:ast data-after-expr))
                  ast0 (assoc ast-after-expr :a (:ast data-after-left))
                  ast1 (assoc ast0 :b (:ast data-after-right))
                  ast2 (assoc ast1 :free-left  free-left)
                  ast3 (assoc ast2 :free-right free-right)

                  ast-after-all ast3

                  ]
              {:ast ast-after-all
               :vars vars-after-all})

        :let (let [;;_ (println (str "\nLET vars in body " (get-maybe ast :result-name) ":\n" vars))

                   init-data (assoc data :pos 0)
                   data-after-bindings (reduce calc-lifetime-for-let-binding init-data (:bindings ast))
                   ;;_ (println (str "data-after-bindings:\n" data-after-bindings))

                   vars-after-bindings (:vars data-after-bindings)                   
                   ast-after-bindings (:ast data-after-bindings)

                   not-eaten-by-bindings (filter (fn (v) (contains? vars-after-bindings v)) vars)
                   eaten-by-bindings (remove (fn (v) (contains? not-eaten-by-bindings v)) vars)
                   ;;_ (println (str "\nLET eaten by bindings in " (get-maybe ast :result-name) ":\n" eaten-by-bindings))

                   ;;_ (println (str "\nlet vars-after-bindings (before body):\n" vars-after-bindings))
                   ;; _ (println (str "ast-after-bindings:\n" ast-after-bindings))

                   ;;_ (println (str "\nLET will visit body of " (get-maybe ast :result-name) ", Current vars:\n" vars-after-bindings))
                   
                   data-after-body (calculate-lifetimes-internal {:ast (:body ast-after-bindings)
                                                                  :vars vars-after-bindings}
                                                                 in-ref)

                   vars-after-body (:vars data-after-body)
                   ;;_ (println (str "\nLET back from visiting body of " (get-maybe ast :result-name) ", Current vars:\n" vars-after-body))
                   
                   ast-after-body (assoc ast-after-bindings :body (:ast data-after-body))

                   ;;_ (println (str "\nlet vars-after-body:\n" vars-after-body))
                   ;; _ (println (str "ast-after-bindings:\n" ast-after-bindings))
                   ;; _ (println (str "ast-after-body:\n" ast-after-body))

                   ;;_ (println (str "\ndata-after-body:\n" data-after-body))

                   vars-after-body-minus-eaten (let [eaten (get-maybe data-after-body :eaten)]
                                                     (if (nil? eaten)
                                                       vars-after-body
                                                       (do
                                                         ;;(println (str "Will eat:\n" eaten))
                                                         (remove (fn (v) (contains? eaten v)) vars-after-body))
                                                       ))
                   ;;_ (println (str "\nLET minus eaten " (get-maybe ast :result-name) ", Current vars:\n" vars-after-body-minus-eaten))

                   ;; only remove the variables that were not already there before entering let form:
                   vars-after-body-and-return-1 (remove (fn (v) (contains? vars v)) vars-after-body-minus-eaten)
                   ;;_ (println (str "\nlet vars-after-body-and-return-1:\n" vars-after-body-and-return-1))
                   
                   vars-after-body-and-return-2 (let [result-name (get-maybe (:body ast-after-body) :result-name)]
                                                  (if (nil? result-name)
                                                    vars-after-body-and-return-1
                                                    (remove-var-with-name vars-after-body-and-return-1 result-name)))
                   ;;_ (println (str "\nlet vars-after-body-and-return-2:\n" vars-after-body-and-return-2))
                   
                   final-ast (assoc ast-after-body :free vars-after-body-and-return-2)
                   final-vars (let [ast-type (:type ast)]
                                (if (managed-type? ast-type)
                                  (cons {:name (:result-name ast) :type ast-type :doc "let ret val"} vars)
                                  vars))
                   ]
               {:ast final-ast
                :vars final-vars
                :eaten eaten-by-bindings})

        :while (let [data-after-expr (calculate-lifetimes-internal {:ast (:expr ast) :vars vars} in-ref)
                     ;;_ (println (str "data-after-expr:\n" data-after-expr))

                     vars-after-expr (:vars data-after-expr)
                     ast-after-expr (assoc ast :expr (:ast data-after-expr))
                     
                     data-after-body (calculate-lifetimes-internal {:ast (:body ast-after-expr) :vars vars-after-expr} in-ref)
                     ;;_ (println (str "data-after-body:\n" data-after-body))
                     ast-after-body (:ast data-after-body)
                     vars-after-body (:vars data-after-body)

                     new-ast-after-body (assoc ast-after-expr :body ast-after-body)
                     vars-after-body-and-return (remove (fn (v) (contains? vars v)) vars-after-body)
                     
                     final-ast (assoc new-ast-after-body :free vars-after-body-and-return)
                     final-vars vars ;; TODO: return value from while-form?
                     ]
                 {:ast final-ast
                  :vars final-vars})        

        :do (let [init-data (assoc data :pos 0)
                  data-after-forms (reduce calc-lifetime-for-do-form init-data (:forms ast))
                  final-ast (:ast data-after-forms)
                  final-eaten (get-maybe data-after-forms :eaten)
                  _ (println (str "do final-eaten: " final-eaten))
                  ]
              {:ast final-ast
               :vars (:vars data-after-forms)
               :eaten final-eaten})
        
        _ data))))

(defn calculate-lifetimes (ast)
  (:ast (calculate-lifetimes-internal {:ast ast
                                       :vars '()}
                                      false)))

