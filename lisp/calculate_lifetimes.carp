
(defn convert-param-node (a)
  {:name (str (:name a))
   :type (:type a)})

(defn managed-type? (t)
  (match t
    (:ref x) false ;; (managed-type? x)
    _ (= t :string)))

(defn manage? (descriptor)
  (managed-type? (:type descriptor)))

(defn dont-free-result-variable (ast vars)
  (let [result-var-name (get-maybe ast :result-name)]
    (do
      ;;(println (str "result-var-name: " result-var-name))
      (if (= nil result-var-name)
        vars
        (remove (fn (v) (= (:name v) result-var-name)) vars)))))

(defn ref? (v)
  (match v
    (:ref _) true
    _ false))

(defn remove-var-with-name (vars name)
  (remove (fn (v) (= name (:name v))) vars))

;; Used for reducing over the args in a function application
(defn calc-lifetime-for-arg (data parameter-types arg-ast)
  (do
    ;; (println "CALCARG. data:\n")
    ;; (println data)
    ;; (println "arg-ast:\n")
    ;; (println arg-ast)
    (let [ast (:ast data)
          vars (:vars data)
          pos (:pos data)
          parameter-type (nth parameter-types pos)
          is-ref (ref? parameter-type)
          new-data (if (and (= :literal (:node arg-ast)) (not is-ref))
                     {:ast arg-ast :vars vars} ;; a literal as an arg to a non-ref parameter doesn't create any new vars to free
                     (calculate-lifetimes-internal {:ast arg-ast
                                                    :vars vars}
                                                   is-ref))
          new-arg-ast (:ast new-data)
          new-vars (:vars new-data)

          ;;_ (println (str "new-arg-ast:\n" new-arg-ast))
          
          new-ast (assoc-in ast (list :tail pos) new-arg-ast)
          ;;_ (println (str "pos " pos " AST: " ast " => " new-ast))
          new-app-data {:ast new-ast
                        :vars new-vars
                        :pos (inc pos)}]
      new-app-data)))

(defn calculate-lifetimes-internal (data in-ref)
  (do
    ;;(println (str "CALC:\n" (:node (:ast data))))
    (let [ast (:ast data)
          vars (:vars data)]
      (match (:node ast)

        :function (let [parameter-nodes (:args ast)
                        new-variables (filter manage? (map convert-param-node parameter-nodes))
                        ;;_ (println (str ":function new-variables: " new-variables))
                        pre-body (:body ast)
                        ;;_ (println (str "\npre-body:\n" pre-body))
                        data-after (calculate-lifetimes-internal {:ast pre-body :vars new-variables} in-ref)
                        vars-after (:vars data-after)
                        vars-with-return-value-removed (dont-free-result-variable (:body ast) vars-after)
                        new-body (:ast data-after)

                        ;;_ (println (str "\nnew-body:\n" new-body))
                        ;;_ (println (str "\nast before:\n" ast))
                        ast-after (assoc ast :body new-body)
                        ;;_ (println (str "\nast after:\n" ast-after))
                        ast-final (assoc ast-after :free vars-with-return-value-removed)
                        ;;_ (println (str "\nast final:\n" ast-final))
                        ]
                    {:ast ast-final
                     :vars '()})

        :literal (let [vars-after (if (managed-type? (:type ast))
                                    (cons {:name (:result-name ast) :type (:type ast)} vars)
                                    vars)
                       ;;_ (println (str "vars-after literal " (:value ast) ": " vars-after))
                       ]
                   {:ast ast
                    :vars vars-after})

        :ref (let [data-after (calculate-lifetimes-internal {:ast (:expr ast) :vars vars} in-ref)]
               {:ast (assoc ast :expr (:ast data-after))
                :vars (:vars data-after)})

        :lookup (let [;;_ (println (str "in-ref: " in-ref ", lookup: " ast))
                      vars-after (if in-ref ;;(ref? (:type ast))
                                   vars
                                   (remove-var-with-name vars (str (:value ast))))
                      ;;_ (when (not (= vars vars-after)) (println (str "Vars before:\n" vars "\nVars after:\n" (:value ast) ": " vars-after)))
                      final-ast {:ast ast
                                 :vars vars-after}

                      ;;_ (println (str "final-ast:\n" final-ast))
                      ]
                  final-ast)

        :binop (let [left (calculate-lifetimes-internal {:ast (:a ast) :vars vars} in-ref)
                     vars-after-left (:vars left)
                     right (calculate-lifetimes-internal {:ast (:b ast) :vars vars-after-left} in-ref)
                     vars-after-right (:vars right)
                     ast0 (assoc ast :a (:ast left))
                     ast1 (assoc ast0 :b (:ast right))]
                 {:ast ast1
                  :vars vars-after-right})

        :app (let [tail (:tail ast)
                   init-data (assoc data :pos 0)
                   parameter-types (get-in ast '(:head :type 1))
                   data-after (reduce (fn (d a) (calc-lifetime-for-arg d parameter-types a)) init-data tail)
                   vars-after (:vars data-after)
                   ret-type (get-in ast '(:head :type 2))
                   vars-after-with-ret-val (if (managed-type? ret-type)
                                             (cons {:name (:result-name ast) :type ret-type} vars-after)
                                             vars-after)
                   ast-after (:ast data-after)]
               (do
                 ;;(println (str "APP VARS AFTER\n" vars-after))
                 {:ast ast-after
                  :vars vars-after-with-ret-val}))

        :if (let [;;_ (println (str "if-ast:\n" ast))
                  data-after-expr (calculate-lifetimes-internal {:ast (:expr ast) :vars vars} in-ref)

                  vars-after-expr (:vars data-after-expr)
                  data-after-left  (calculate-lifetimes-internal {:ast (:a ast) :vars vars-after-expr} in-ref)
                  data-after-right (calculate-lifetimes-internal {:ast (:b ast) :vars vars-after-expr} in-ref)
                  ;;_ (println (str "data-after-left:\n" data-after-left "\ndata-after-right:\n" data-after-right))

                  vars-after-left  (let [result-name (get-maybe (:a ast) :result-name)
                                         vs (:vars data-after-left)]
                                     (if (nil? result-name)
                                       vs
                                       (remove-var-with-name vs result-name)))
                  
                  vars-after-right (let [result-name (get-maybe (:b ast) :result-name)
                                         vs (:vars data-after-right)]
                                     (if (nil? result-name)
                                       vs
                                       (remove-var-with-name vs result-name)))

                  new-vars-left  (remove (fn (v) (contains? vars-after-expr v)) vars-after-left) ;; the NEW vars after visiting this branch
                  new-vars-right (remove (fn (v) (contains? vars-after-expr v)) vars-after-right)

                  ;;_ (println (str "vars-after-left:\n" vars-after-left "\nvars-after-right:\n" vars-after-right))

                  vars-after-all (intersection vars-after-left vars-after-right)
                  vars-removed (filter (fn (v) (contains? vars-after-expr v)) vars-after-expr) ;; vars "eaten" by either the left or right branch

                  ;;_ (println (str "vars removed:\n" vars-removed))
                  
                  free-left  (concat new-vars-left
                                     (remove (fn (v) (contains? vars-after-right v)) vars-removed))
                  free-right (concat new-vars-right
                                     (remove (fn (v) (contains? vars-after-left  v)) vars-removed))

                  ;;_ (println (str "free-left:\n" free-left "\nfree-right:\n" free-right))
                  
                  ast-after-expr (assoc ast :expr (:ast data-after-expr))
                  ast0 (assoc ast-after-expr :a (:ast data-after-left))
                  ast1 (assoc ast0 :b (:ast data-after-right))
                  ast2 (assoc ast1 :free-left  free-left)
                  ast3 (assoc ast2 :free-right free-right)

                  ast-after-all ast3

                  ]
              {:ast ast-after-all
               :vars vars-after-all}
              )
        
        _ data))))

(defn calculate-lifetimes (ast)
  (:ast (calculate-lifetimes-internal {:ast ast
                                       :vars '()}
                                      false)))

