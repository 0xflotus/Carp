(load-lisp (str carp-dir "lisp/error_codes.carp"))
(load-lisp (str carp-dir "lisp/compiler_helpers.carp"))
(load-lisp (str carp-dir "lisp/ast.carp"))
(load-lisp (str carp-dir "lisp/infer_types.carp"))
(load-lisp (str carp-dir "lisp/generate_names.carp"))
(load-lisp (str carp-dir "lisp/calculate_lifetimes.carp"))
(load-lisp (str carp-dir "lisp/builder.carp"))
(load-lisp (str carp-dir "lisp/func_deps.carp"))
(load-lisp (str carp-dir "lisp/generics.carp"))
(load-lisp (str carp-dir "lisp/structs.carp"))
(load-lisp (str carp-dir "lisp/globals.carp"))
(load-lisp (str carp-dir "lisp/cc.carp"))
(load-lisp (str carp-dir "lisp/annotate.carp"))
(load-lisp (str carp-dir "lisp/graph.carp"))

(def header-files (list "\"declarations.h\"" "\"shared.h\""))
(def extra-header-deps ())

(def baked-primops ())

(defn func-baked? [func-name]
  (not (nil? (get-maybe graph func-name))))

(defn get-func-deps-recursively [func-name]
  (if (has-key? graph (str func-name))
    (let [deps (get-in graph (list (str func-name) :deps))]
      (concat deps (mapcat get-func-deps-recursively deps)))
    '()))

(def log-unloading-of-dylibs false)

;; Takes the name of a function and unloads it if it is in the list of baked functions
(defn unload-if-necessary (func-name)
  (let [baked-node (get-maybe graph func-name)]
    (when (not (nil? baked-node))
      (let [dylib (get baked-node :dylib-ptr)]
        (do (when log-unloading-of-dylibs
              (println (str "Unloading " dylib " for function " func-name ".")))
            (unload-dylib dylib)
            (dict-remove! graph func-name)
            )))))

(defn re-lambda-fy [func-name]
  (let [function-symbol (if (symbol? func-name)
                          func-name
                          (symbol func-name))
        func (eval function-symbol)]
    (if (foreign? func)
      (let [func-code (meta-get func :code)]
        (do
          ;;(println (str "re-lambda-fy:ing baked function '" func-name "' using original code: " func-code))
          (eval (list 'def (symbol func-name) func-code))
          (unload-if-necessary func-name)))
      (do
        ;;(println (str "re-lambda-fy will ignore non-baked function: " func-name))
        :ignore))))

(defn re-lambda-fy-all-functions []
  (do
    (map re-lambda-fy (keys graph))))

(defn re-compile [func-name]
  (let [function-symbol (symbol func-name)
        func (eval function-symbol)]
      (if (lambda? func)
        (let [func-code (code (eval (symbol func-name)))]
          (do
            ;;(println (str "Compiling dynamic (lambda) function '" func-name "' using its code: " func-code))
            (bake-internal func-name func-code (meta-get func :ann) '() false)))
        (do
          ;;(println (str "re-compile will ignore non-lambda: " func))
          :ignore))))

(defn unload-all-baked ()
  (join "\n" (map (fn (x) (str (unload-dylib (:dylib-ptr x)))) (values graph))))

;; (def types {})

;; (defn add-type! [type-name type-definition]
;;   (swap! types (fn (ts) (assoc ts type-name {:type-name type-name
;;                                              :type-definition type-definition}))))

;; Saves the signatures of all the baked functions to a header file so that they can include each other
(defn save-function-prototypes ()
  (save (str out-dir "declarations.h")
        (str
         "#include <shared.h>\n"
         (join "\n" (map (fn [header] (str "#include " header)) extra-header-deps))
         "\n\n//Structs:\n"
         (join "\n" (map :proto (filter (fn [n] (= (:kind n) :struct)) (values graph))))
         "\n\n//Function types:\n"
         (join "\n" (map :proto (filter (fn [n] (= (:kind n) :function-type)) (values graph))))
         "\n\n//Globals:\n"
         (join "\n" (map :proto (filter (fn [n] (= (:kind n) :global)) (values graph))))
         "\n\n//Functions:\n"
         (join "\n" (map :proto (filter (fn [n] (= (:kind n) :function)) (values graph))))
         "\n")))

;; Keys:   Names of functions (strings)
;; Values: A list of all the functions that depend on this particular function
(def function-dependency-graph {})

(defn add-function-dependency! [target-function name-of-depending-function]
  (let [current-list (get-maybe function-dependency-graph target-function)]
    (reset! function-dependency-graph (assoc function-dependency-graph target-function (cons name-of-depending-function current-list)))))

(def echo-signature-after-bake false)

(defn remove-non-user-defined-deps (func-deps)
  (let [func-names (keys graph)]
    (filter (fn (dep) (contains? func-names (str dep))) func-deps)))

;; Takes a function name and the list representation of the lambda
(defn bake-internal [func-name func-code func-annotation external-deps exe]
  (let [annotated-ast (func-to-annotated-ast func-name func-code func-annotation nil)]
    (if (generic-function? annotated-ast)
      (do
        ;;(println (str "bake found generic function: " func-name))
        (let [func-def (eval (symbol func-name))]
          (do
            (meta-set! func-def :generic true)
            (meta-set! func-def :signature (:type annotated-ast))
            (def ast annotated-ast)
            (def s (pretty-signature (:type annotated-ast)))
            (if echo-signature-after-bake
              (println (str func-name " : " s))
              nil))))
      (bake-internal-common annotated-ast (new-builder) func-name func-code external-deps exe))))

(defn bake-generic-func-internal [func-name func-code external-deps exe func-signature]
  (let [ast-annotated (func-to-annotated-ast func-name func-code nil func-signature)]
    (if (generic-function? ast-annotated)
      (error (str "Failed to concretizise generic function " func-name ":\n" ast-annotated))
      (bake-internal-common ast-annotated (new-builder) func-name func-code external-deps exe))))

(defn get-depending-funcs-recursively [func-name]
  (let [depending-funcs (get-maybe function-dependency-graph func-name)]
    (concat depending-funcs (mapcat get-depending-funcs-recursively depending-funcs))))

(defn bake-function-and-its-depending-funcs [func-name external-deps]
  (if (foreign? (eval (symbol func-name)))
    :already-baked
    (let [functions-depending-on-this-function (set (get-depending-funcs-recursively func-name))]
      (do
        ;;(println (str "Baking '" func-name "' and its users: " (join ", " functions-depending-on-this-function)))
        (unload-if-necessary func-name)
        (map unload-if-necessary functions-depending-on-this-function)
        (map re-lambda-fy functions-depending-on-this-function)
        (map re-compile functions-depending-on-this-function)
        (let [evaled (eval (symbol func-name))]
          (if (foreign? evaled)
            (do
              ;;(println (str "The functions depending on " func-name " already made it recompile, no need to bake again."))
              :OK)
            (bake-internal func-name (code evaled) (meta-get evaled :ann) external-deps false)))))))

;; Do the part that is common between baking normal functions and generic functions
(defn bake-internal-common [ast-annotated builder func-name func-code external-deps exe]
  (let [old-builder-deps (:deps builder)
        builder-result (builder-visit-ast builder ast-annotated func-name)
        builder-after-build (:builder builder-result)
        ;;(assoc shared-builder :functions (union (:functions shared-builder) (:functions (:builder builder-result))))
        builder-with-headers (builder-add-headers builder-after-build header-files)
        builder-deps (:deps builder-result)
        builder-final (if (and exe (not (= func-name "main")))
                        (builder-add-main-function builder-with-headers (c-ify-name func-name))
                        builder-with-headers)
        c-program-string (builder-merge-to-c builder-final)
        proto (get-function-prototype ast-annotated func-name)
        c-func-name (c-ify-name func-name)
        c-file-name (str out-dir c-func-name ".c")
        total-dependencies (if exe '() (set (concat (remove-non-user-defined-deps (:func-deps ast-annotated)) external-deps builder-deps old-builder-deps)))
        final-builder-with-deps (reduce (fn [b dep] (builder-add b :deps dep)) builder-final total-dependencies)
        t (get ast-annotated :type)
        ]
    (do    
      ;; (println (str "External deps for " func-name ": " (join ", " external-deps)))
      ;; (println (str "Func deps for " func-name ": " (join ", " (:func-deps ast-annotated))))
      ;; (println (str "Builder deps for " func-name ": " (join ", " builder-deps)))
      ;; (println (str "Total deps for " func-name ": " (join ", " total-dependencies)))
      
      (map (fn [dep] (add-function-dependency! (str dep) func-name)) total-dependencies)
      (def ast ast-annotated)
      (def c c-program-string)
      ;;(println (str "Will save and compile: '" func-name "' with c-func-name '" c-func-name "' and signature: " t))
      (save-and-compile func-name t c-func-name c-file-name c-program-string proto total-dependencies exe)
      (meta-set! (eval (symbol func-name)) :code func-code))))

;; This will bake the function as a dylib (making it accessible in the repl) AND also add it to the shared builder if that exists
(defn bake-c-code [func-name signature c-func-name c-file-name c-program-string includes-string proto deps false]
  (save-and-compile func-name signature c-func-name c-file-name (str includes-string c-program-string) proto deps false))

(defn save-and-compile [func-name t c-func-name c-file-name c-program-string proto total-dependencies exe]
  (match t
    (:fn arg-types return-type) (do
                                  (save-function-prototypes)
                                  (save c-file-name c-program-string)
                                  (run-compiler c-func-name c-file-name total-dependencies exe)
                                  (unload-if-necessary func-name)
                                  (if exe
                                    :exe-done
                                    (let [dylib-name (str out-dir c-func-name (:dylib-extension platform-specifics))]
                                      (do
                                        (def out-lib (load-dylib dylib-name))
                                        (register out-lib c-func-name arg-types return-type)
                                        (graph/add-node! :function func-name proto c-program-string dylib-name out-lib total-dependencies)
                                        (let [f (eval (read func-name))
                                              sig (signature f)]
                                          (do (when (nil? sig) (error (str "No signature on function " f)))
                                              (when echo-signature-after-bake (println (str func-name " : " sig)))
                                              f))))))
    variable-type (let [dylib-name (str out-dir c-func-name (:dylib-extension platform-specifics))]
                    (do
                      (save-function-prototypes)
                      (save c-file-name c-program-string)
                      (run-compiler c-func-name c-file-name total-dependencies exe)
                      (unload-if-necessary func-name)
                      (def out-lib (load-dylib dylib-name))
                      (register-variable out-lib c-func-name variable-type)
                      (graph/add-node! :global func-name proto c-program-string dylib-name out-lib total-dependencies)
                      (let [f (eval (read func-name))]
                        f)))
    _ (error "Must bake function with type (:fn ...)")))

;; Bake a function in the current environment, just give it's symbol
(defmacro bake (func-symbol)
  (list 'bake-function-and-its-depending-funcs (str func-symbol) '()))

(defmacro bake-exe (func-symbol)
  (list 'do (list 'bake-internal (str func-symbol) (list 'code func-symbol) (list 'meta-get func-symbol :ann) '() true)))

(defmacro bake* (func-symbol dependencies)
  (list 'bake-internal (str func-symbol) (list 'code func-symbol) (list 'meta-get func-symbol :ann) dependencies false))

(defmacro bake-exe* (func-symbol dependencies)
  (list 'bake-internal (str func-symbol) (list 'code func-symbol) (list 'meta-get func-symbol :ann) dependencies true))

