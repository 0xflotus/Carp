(load-lisp (str carp-dir "lisp/error_codes.carp"))
(load-lisp (str carp-dir "lisp/compiler_helpers.carp"))
(load-lisp (str carp-dir "lisp/ast.carp"))
(load-lisp (str carp-dir "lisp/infer_types.carp"))
(load-lisp (str carp-dir "lisp/generate_names.carp"))
(load-lisp (str carp-dir "lisp/calculate_lifetimes.carp"))
(load-lisp (str carp-dir "lisp/builder.carp"))
(load-lisp (str carp-dir "lisp/func_deps.carp"))
(load-lisp (str carp-dir "lisp/generics.carp"))
(load-lisp (str carp-dir "lisp/structs.carp"))
(load-lisp (str carp-dir "lisp/globals.carp"))
(load-lisp (str carp-dir "lisp/cc.carp"))
(load-lisp (str carp-dir "lisp/annotate.carp"))
(load-lisp (str carp-dir "lisp/graph.carp"))

(def header-files (list "\"declarations.h\"" "\"shared.h\""))

(defn re-compile [func-name]
  (let [function-symbol (symbol func-name)
        func (eval function-symbol)]
    (if (lambda? func)
      (let [func-code (code (eval (symbol func-name)))]
        (do
          ;;(println (str "Compiling dynamic (lambda) function '" func-name "' using its code: " func-code))
          (bake-internal func-name func-code (meta-get func :ann) '() false (new-builder))))
      (do
        ;;(println (str "re-compile will ignore non-lambda: " func))
        :ignore))))

(def echo-signature-after-bake false)

(defn remove-non-user-defined-deps [deps]
  (let [names (keys graph)]
    (filter (fn (dep) (contains? names (str dep))) deps)))

;; Takes a function name and the list representation of the lambda
(defn bake-internal [func-name func-code func-annotation external-deps exe builder]
  (let [annotated-ast (func-to-annotated-ast func-name func-code func-annotation nil)]
    (if (generic-function? annotated-ast)
      (mark-lambda-as-generic func-name annotated-ast)
      (bake-internal-common annotated-ast builder func-name func-code external-deps exe))))

;; Do the part that is common between baking normal functions and generic functions
(defn bake-internal-common [ast-annotated builder func-name func-code external-deps exe]
  (let [old-builder-deps (:deps builder)
        builder-result (builder-visit-ast builder ast-annotated func-name)
        builder-after-build (:builder builder-result)
        ;;(assoc shared-builder :functions (union (:functions shared-builder) (:functions (:builder builder-result))))
        builder-with-headers builder-after-build ;; (builder-add-headers builder-after-build header-files)
        builder-deps (:deps builder-result)
        builder-final (if (and exe (not (= func-name "main")))
                        (builder-add-main-function builder-with-headers (c-ify-name func-name))
                        builder-with-headers)
        c-program-string (builder-merge-to-c builder-final)
        proto (get-function-prototype ast-annotated func-name)
        c-func-name (c-ify-name func-name)
        c-file-name (str out-dir c-func-name ".c")
        total-dependencies (if exe '() (set (concat (remove-non-user-defined-deps (:func-deps ast-annotated)) external-deps builder-deps old-builder-deps)))
        final-builder-with-deps (reduce (fn [b dep] (builder-add b :deps dep)) builder-final total-dependencies)
        t (get ast-annotated :type)
        ]
    (do    
      ;; (println (str "External deps for " func-name ": " (join ", " external-deps)))
      ;; (println (str "Func deps for " func-name ": " (join ", " (:func-deps ast-annotated))))
      ;; (println (str "Builder deps for " func-name ": " (join ", " builder-deps)))
      ;; (println (str "Total deps for " func-name ": " (join ", " total-dependencies)))

      (def ast ast-annotated)
      (def c c-program-string)
      ;;(println (str "Will save and compile: '" func-name "' with c-func-name '" c-func-name "' and signature: " t))
      (save-and-compile func-name t c-func-name c-file-name c-program-string proto total-dependencies exe)
      (meta-set! (eval (symbol func-name)) :code func-code))))

(defn bake-generic-func-internal [func-name func-code external-deps exe func-signature]
  (let [ast-annotated (func-to-annotated-ast func-name func-code nil func-signature)]
    (if (generic-function? ast-annotated)
      (error (str "Failed to concretizise generic function " func-name ":\n" ast-annotated))
      (bake-internal-common ast-annotated (new-builder) func-name func-code external-deps exe))))

(defn bake-function-and-its-depending-funcs [func-name external-deps]
  (if (foreign? (eval (symbol func-name)))
    :already-baked
    (let [functions-depending-on-this-function (graph/dependers func-name)]
      (do
        ;;(println (str "Baking '" func-name "' and its users: " (join ", " functions-depending-on-this-function)))
        (graph/unload func-name)
        (map graph/unload functions-depending-on-this-function)
        (map graph/re-lambda-fy functions-depending-on-this-function)
        (map re-compile functions-depending-on-this-function)
        (let [evaled (eval (symbol func-name))]
          (if (foreign? evaled)
            (do
              ;;(println (str "The functions depending on " func-name " already made it recompile, no need to bake again."))
              :OK)
            (bake-internal func-name (code evaled) (meta-get evaled :ann) external-deps false (new-builder))))))))

;; This will bake the function as a dylib (making it accessible in the repl) AND add it to the 'graph'
(defn bake-c-code [func-name signature c-func-name c-file-name c-program-string proto deps exe]
  (save-and-compile func-name signature c-func-name c-file-name c-program-string proto deps exe))

(defn save-and-compile [func-name t c-func-name c-file-name c-program-string proto total-dependencies exe]
  (match t
    (:fn arg-types return-type) (do
                                  (graph/save-prototypes!)
                                  (save c-file-name (str "#include \"declarations.h\"\n\n" c-program-string))
                                  (run-compiler c-func-name c-file-name total-dependencies exe)
                                  (graph/unload func-name)
                                  (if exe
                                    :exe-done
                                    (let [dylib-name (str out-dir c-func-name (:dylib-extension platform-specifics))]
                                      (do
                                        (def out-lib (load-dylib dylib-name))
                                        (register out-lib c-func-name arg-types return-type)
                                        (graph/add-node! :function func-name proto c-program-string dylib-name out-lib total-dependencies)
                                        (let [f (eval (read func-name))
                                              sig (signature f)]
                                          (do (when (nil? sig) (error (str "No signature on function " f)))
                                              (when echo-signature-after-bake (println (str func-name " : " sig)))
                                              f))))))
    variable-type (let [dylib-name (str out-dir c-func-name (:dylib-extension platform-specifics))]
                    (do
                      (graph/save-prototypes!)
                      (save c-file-name c-program-string)
                      (run-compiler c-func-name c-file-name total-dependencies exe)
                      (graph/unload func-name)
                      (def out-lib (load-dylib dylib-name))
                      (register-variable out-lib c-func-name variable-type)
                      (graph/add-node! :global func-name proto c-program-string dylib-name out-lib total-dependencies)
                      (let [f (eval (read func-name))]
                        f)))
    _ (error "Must bake function with type (:fn ...)")))

;; Bake a function in the current environment, just give it's symbol
(defmacro bake (func-symbol)
  (list 'bake-function-and-its-depending-funcs (str func-symbol) '()))

(defmacro bake-exe (func-symbol)
  (list 'do (list 'bake-internal (str func-symbol) (list 'code func-symbol) (list 'meta-get func-symbol :ann) '() true)))

(defmacro bake* (func-symbol dependencies)
  (list 'bake-internal (str func-symbol) (list 'code func-symbol) (list 'meta-get func-symbol :ann) dependencies false (list 'new-builder)))

(defmacro bake-exe* (func-symbol dependencies)
  (list 'bake-internal (str func-symbol) (list 'code func-symbol) (list 'meta-get func-symbol :ann) dependencies true))







;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmacro compiler/bake (func-symbol)
  (list 'compiler/bake-function-and-its-dependers (str func-symbol)))

(defn compiler/bake-function-and-its-dependers [func-name]
  (if (foreign? (eval (symbol func-name)))
    :already-baked
    (let [dependers (graph/dependers func-name)]
      (do
        (println (str "Compiler is baking '" func-name "' and its users: " (join ", " dependers)))
        (graph/unload func-name)
        (map graph/unload dependers)
        (map graph/re-lambda-fy dependers)
        (map compiler/try-bake dependers)
        (compiler/try-bake func-name)))))

^doc "If it's a lambda this will either bake it or mark it as generic. If it's not a lambda it will be ignored."
(defn compiler/try-bake [func-name]
  (let [func (eval (symbol func-name))]
    (if (lambda? func)
      (let [annotated-ast (func-to-annotated-ast func-name (code func) nil (meta-get func :ann))]
        (if (generic-function? annotated-ast)
          (mark-lambda-as-generic func-name annotated-ast)
          (compiler/bake-ast func-name annotated-ast (code func))))
      (println (str "compiler/try-bake will ignore non-lambda '" func-name "'")))))

^doc "Compile a generic lambda to a specific, fully typed version by providing a signature with the types needed."
(defn compiler/concretize [func-name func-code func-signature]
  (let [annotated-ast (func-to-annotated-ast func-name func-code func-signature nil)]
    (if (generic-function? annotated-ast)
      (error (str "Failed to concretize generic function " func-name ":\n" annotated-ast))
      (compiler/bake-ast func-name annotated-ast func-code))))

(def log-deps-when-baking-ast false)

(defn compiler/bake-ast [func-name ast-annotated original-code]
  (let [build-result (builder-visit-ast (new-builder) ast-annotated func-name)
        builder-deps (:deps build-result) ;; dependencies on destructors found during the builder phase
        c-program-string (builder-merge-to-c (:builder build-result))
        proto (get-function-prototype ast-annotated func-name)
        c-func-name (c-ify-name func-name)
        c-file-name (str out-dir c-func-name ".c")
        total-deps (set (concat (remove-non-user-defined-deps (:func-deps ast-annotated)) builder-deps))
        func-signature (get ast-annotated :type)]
    (do
      (when log-deps-when-baking-ast
        (do
          (println (str "Func deps for " func-name ": " (join ", " (:func-deps ast-annotated))))
          (println (str "Builder deps for " func-name ": " (join ", " builder-deps)))
          (println (str "Total deps for " func-name ": " (join ", " total-deps)))))
      (def c c-program-string)
      (compiler/bake-group func-name
                           (list {:name func-name
                                  :proto proto
                                  :src c-program-string
                                  :sig func-signature})
                           total-deps)
      (meta-set! (eval (symbol func-name)) :code original-code))))

(defn compiler/bake-src [func-name proto src func-signature deps]
  (compiler/bake-group func-name
                       (list {:name func-name
                              :proto proto
                              :src src
                              :sig func-signature})
                       deps))

^doc "A 'group' is one unit of compilation, like a .so or .dll file.
      The 'code-node':s sent to this function are dictionaries describing
      all the functions that go into the same group."
(defn compiler/bake-group [group-name code-nodes deps]
  (let [src (with-declarations-header (join "\n\n" (map (fn [d] (:src d)) code-nodes)))
        c-file-name (str out-dir group-name ".c")
        dylib-name (str out-dir group-name (:dylib-extension platform-specifics))]
    (do
      (println (str "Compiling group '" group-name "'."))
      (def src src)
      (map (fn [code-node]
             (graph/add-node! :function (:name code-node) (:proto code-node) (:src code-node) dylib-name nil deps))
           code-nodes)
      (graph/save-prototypes!)
      (save c-file-name src)
      (run-compiler group-name c-file-name deps false)
      (def out-lib (load-dylib dylib-name))
      (map (fn [code-node]
             (let [c-func-name (c-ify-name (:name code-node))
                   arg-types (nth (:sig code-node) 1)
                   return-type (nth (:sig code-node) 2)]
               (do
                 (register out-lib c-func-name arg-types return-type)
                 (graph/update-node! (:name code-node) :dylib-ptr out-lib))))
           code-nodes)
      :OK)))

(defn with-declarations-header [s] (str "#include \"declarations.h\"\n\n" s))

(def example-descriptor-1 {:src "int f() { return 42; }"
                           :proto "int f();"
                           :name "f"
                           :sig '(:fn () :int)})

(def example-descriptor-2 {:src "int g() { return f() + f(); }"
                           :proto "int g();"
                           :name "g"
                           :sig '(:fn () :int)})

(defn test-it []
  (compiler/bake-group "efgroup" (list example-descriptor-1 example-descriptor-2) ()))
