
(defn test-replace-in-list ()
  (assert-eq (replace-in-list '(10 20 30) 20 "hej") '(10 "hej" 30)))

(test-replace-in-list)

(defn test-replace-from-right ()
  (do
    (assert-eq (replace-subst-from-right {:a :b :c :d} :b :e) {:a :e :c :d})
    (assert-eq (replace-subst-from-right {:a :b :c :b} :b :e) {:a :e :c :e})
    (assert-eq (replace-subst-from-right {:a (list :b :b) :c :d} :b :f) {:a (list :f :f) :c :d})))

(test-replace-from-right)

(defn test-constraint-solving-1 ()
  (let [;;_ (println "\n- Constraint solving 1 -")
        constraints (list {:a :int :b "t0"})
        solution (solve-constraints constraints)
        solution-backwards (solve-constraints (reverse constraints))]
    (do
      (assert-eq solution {"t0" :int})
      (assert-eq solution solution-backwards))))

(defn test-constraint-solving-2 ()
  (let [;;_ (println "\n- Constraint solving 2 -")
        constraints (list {:a :int :b "t0"}
                          {:a "t1" :b "t0"})
        solution (solve-constraints constraints)
        ;;_ (println "\n- Backwards -")
        solution-backwards (solve-constraints (reverse constraints))]
    (do
      (assert-eq solution {"t0" :int "t1" :int})
      (assert-eq solution solution-backwards))))

(defn test-constraint-solving-3 ()
  (let [;;_ (println "\n- Constraint solving 3 -")
        constraints (list {:a (list :bool :float) :b (list "t0" "t1")})
        solution (solve-constraints constraints)
        ;;_ (println "\n- Backwards -")
        solution-backwards (solve-constraints (reverse constraints))]
    (do
      (assert-eq solution {"t0" :bool "t1" :float})
      (assert-eq solution solution-backwards))))

(defn test-constraint-solving-4 ()
  (let [;;_ (println "\n- Constraint solving 4 -")
        constraints (list {:a (list :ref "t0") :b (list :ref :string)})
        solution (solve-constraints constraints)
        ;;_ (println "\n- Backwards -")
        solution-backwards (solve-constraints (reverse constraints))]
    (do
      (assert-eq solution {"t0" :string})
      (assert-eq solution solution-backwards))))

(defn test-constraint-solving-5 ()
  (let [;;_ (println "\n- Constraint solving 5 -")
        constraints (list {:a (list :ref "t0") :b "t1"}
                          {:a "t1" :b (list :ref :int)})
        solution (solve-constraints constraints)
        ;;_ (println "\n- Backwards -")
        solution-backwards (solve-constraints (reverse constraints))]
    (do
      (assert-eq solution {"t0" :int
                           "t1" (list :ref :int)})
      (assert-eq solution solution-backwards))))

(defn test-constraint-solving-6 ()
  (let [;;_ (println "\n- Constraint solving 6 -")
        constraints (list {:a "t0" :b "t0"}
                          {:a "t0" :b "t1"}
                          {:a "t1" :b :float}
                          {:a "t1" :b "t1"})
        solution (solve-constraints constraints)
        ;;_ (println "\n- Backwards -")
        solution-backwards (solve-constraints (reverse constraints))]
    (do
      (assert-eq solution {"t0" :float
                           "t1" :float})
      (assert-eq solution solution-backwards))))

(test-constraint-solving-1)
(test-constraint-solving-2)
(test-constraint-solving-3)
(test-constraint-solving-4)
(test-constraint-solving-5)
(test-constraint-solving-6)



(defn fib (n)
  (if (< n 2)
    1
    (+ (fib (- n 2)) (fib (- n 1)))))

(defn test-fib ()
  (do
    (bake fib)
    (assert-eq (fib 6) 13)
    (assert-eq (type fib) :foreign)
    :fib-is-ok))



(defn foo (x)
  (+ (- (fib x) 100) 7))

(defn test-foo ()
  (do (bake* foo '(fib))
      (assert-eq (foo 6) -80)
      (assert-eq (type foo) :foreign)
      :foo-is-ok))



(defn hypo (x y)
  (sqrtf (+ (* x x) (* y y))))

(defn test-hypo ()
  (do (bake hypo)
      (assert-approx-eq (hypo 3.0 4.0) 5.0)
      (assert-eq (type hypo) :foreign)
      :hypo-is-ok))



(test-fib)
(test-foo)
(test-hypo)



(defn f (s)
  (strlen s))

(defn g (x s)
  (* x (f s)))

(defn h (x)
  (if "blorg" "Hej" x))

(def fast (lambda-to-ast (code f)))
(def fcon (gencon fast))
(def fasta (annotate-ast fast))

(def hast (lambda-to-ast (code h)))
(def hcon (gencon hast))
(def hasta (annotate-ast hast))

(defn fuck ()
  (+ "hej" 23))

(def fuckast (lambda-to-ast (code fuck)))
(def fuckcon (gencon fuckast))
;;(def fuckasta (annotate-ast fuckast))

(defn mix (x y z)
  (if (< (strlen z) 3) (* (itof y) x) x))

;; (def mixast (lambda-to-ast (code mix)))
;; (def mixcon (gencon mixast))
;; (def mixasta (annotate-ast mixast))

(defn monad ()
  (do (strlen "hej")
      (strlen "svej")
      (strlen "yay")))

(def monast (lambda-to-ast (code monad)))
(def moncon (gencon monast))
(def monasta (annotate-ast monast))



(defn test-loading ()
  (do
    (save "out/out.c" "int f() { return 100; }")
    (system "clang -shared -o out/f.so out/out.c")
    (def flib (load-dylib "out/f.so"))
    (register flib "f" () :int)
    (assert-eq 100 (f))
    
    (save "out/out.c" "int g() { return 150; }")
    (system "clang -shared -o out/g.so out/out.c")
    (def glib (load-dylib "out/g.so"))
    (register glib "g" () :int)
    (assert-eq 150 (g))
    
    (unload-dylib flib)
    
    (save "out/out.c" "int f() { return 200; }")
    (system "clang -shared -o out/f.so out/out.c")
    (def flib (load-dylib "out/f.so"))
    (register flib "f" () :int)
    (assert-eq 200 (f))
    ))

;; This does NOT work!
(defn shadow (x)
  (let [x (* x 3)]
    x))
;; (def shadowast (lambda-to-ast (code shadow)))
;; (def shadowcon (gencon shadowast))
;; (def shadowasta (annotate-ast shadowast))



;; This one is weird:
(defn own-string-weird (s)
  (ref s))



(register-builtin "eat_string" '(:string) :void)

(defn own-string-1 ()
  (strlen (ref "hej")))

(def own-ast-1 (lambda-to-ast (code own-string-1)))
(def own-con-1 (gencon own-ast-1))
(def own-asta-1 (annotate-ast own-ast-1))
(let [free (:free own-asta-1)]
  (do (assert-eq 1 (count free))
      (assert-eq :string (:type (nth free 0)))))


(defn own-string-2 ()
  (eat-string "hej"))

(def own-ast-2 (lambda-to-ast (code own-string-2)))
(def own-con-2 (gencon own-ast-2))
(def own-asta-2 (annotate-ast own-ast-2))
(let [free (:free own-asta-2)]
  (do (assert-eq 0 (count free))
      (assert-eq '(:arrow () :void) (:type own-asta-2))))


(defn own-string-3 ()
  "hej")

(def own-ast-3 (lambda-to-ast (code own-string-3)))
(def own-con-3 (gencon own-ast-3))
(def own-asta-3 (annotate-ast own-ast-3))
(let [free (:free own-asta-3)]
  (do (assert-eq 0 (count free))
      (assert-eq '(:arrow () :string) (:type own-asta-3))))


(defn own-string-4 (s)
  (eat-string s))

(def own-ast-4 (lambda-to-ast (code own-string-4)))
(def own-con-4 (gencon own-ast-4))
(def own-asta-4 (annotate-ast own-ast-4))
(let [free (:free own-asta-4)]
  (do (assert-eq 0 (count free))
      (assert-eq '(:arrow (:string) :void) (:type own-asta-4))))


(defn own-string-5 (s)
  (strlen s))

(def own-ast-5 (lambda-to-ast (code own-string-5)))
(def own-con-5 (gencon own-ast-5))
(def own-asta-5 (annotate-ast own-ast-5))
(let [free (:free own-asta-5)]
  (do (assert-eq 0 (count free))
      (assert-eq '(:arrow ((:ref :string)) :int) (:type own-asta-5))))


(defn own-string-6 (sr)
  (strlen (ref sr)))

(def own-ast-6 (lambda-to-ast (code own-string-6)))
(def own-con-6 (gencon own-ast-6))
(def own-asta-6 (annotate-ast own-ast-6))
(let [free (:free own-asta-6)]
  (do (assert-eq 1 (count free))
      (assert-eq :string (:type (nth free 0)))
      (assert-eq '(:arrow (:string) :int) (:type own-asta-6))))


;; (bake own-string-1)
;; (bake own-string-2)
;; (bake own-string-3)
;; (bake own-string-4)
;; (bake own-string-5)
;; (bake own-string-6)






(defn own-string-7 (s1 s2)
  (str-append (ref s2) (str-append (ref s1) (ref s2))))

(def own-ast-7 (lambda-to-ast (code own-string-7)))
(def own-con-7 (gencon own-ast-7))
(def own-asta-7 (annotate-ast own-ast-7))
(let [free (:free own-asta-7)]
  (do (assert-eq '(:arrow (:string :string) :string) (:type own-asta-7))
      (assert-eq 3 (count free))
      (bake own-string-7)
      (assert-eq (own-string-7 "a" "b") "bab")))



(defn own-string-8 (s1 s2)
  (str-append (ref s2) (str-append (ref s1) "!")))

(def own-ast-8 (lambda-to-ast (code own-string-8)))
(def own-con-8 (gencon own-ast-8))
(def own-asta-8 (annotate-ast own-ast-8))
(let [free (:free own-asta-8)]
  (do (assert-eq '(:arrow (:string :string) :string) (:type own-asta-8))
      (assert-eq 4 (count free))
      (assert-eq :string (:type (nth free 0)))
      (assert-eq :string (:type (nth free 1)))
      (assert-eq :string (:type (nth free 2)))
      (assert-eq :string (:type (nth free 3)))
      (bake own-string-8)
      (assert-eq (own-string-8 "a" "b") "ba!")))


(defn own-string-9 (s x)
  (str-append (itos (* x x)) s))

(def own-ast-9 (lambda-to-ast (code own-string-9)))
(def own-con-9 (gencon own-ast-9))
(def own-asta-9 (annotate-ast own-ast-9))
(let [free (:free own-asta-9)]
  (do (assert-eq '(:arrow ((:ref :string) :int) :string) (:type own-asta-9))
      (assert-eq 1 (count free))
      (assert-eq :string (:type (nth free 0)))
      (bake own-string-9)
      (assert-eq (own-string-9 "hello" 3) "9hello")))


(defn own-string-9b (s)
  (strlen (own-string-9 (ref s) 5)))

(def own-ast-9b (lambda-to-ast (code own-string-9b)))
(def own-con-9b (gencon own-ast-9b))
(def own-asta-9b (annotate-ast own-ast-9b))
(let [free (:free own-asta-9b)]
  (do (assert-eq '(:arrow (:string) :int) (:type own-asta-9b))
      (bake* own-string-9b '(own-string-9))
      (assert-eq 2 (count free))
      (assert-eq :string (:type (nth free 0)))
      (assert-eq :string (:type (nth free 1)))
      (assert-eq "s" (:name (nth free 1)))
      (assert-eq (own-string-9b "yeah") 6)))




(defn own-if-10 (s)
  (if (< (strlen s) 10) "short" "long"))

(def own-ast-10 (lambda-to-ast (code own-if-10)))
(def own-con-10 (gencon own-ast-10))
(def own-asta-10 (annotate-ast own-ast-10))
(let [free (:free own-asta-10)]
  (do (assert-eq '(:arrow ((:ref :string)) :string) (:type own-asta-10))
      (bake own-if-10)
      (assert-eq 0 (count free))
      (assert-eq (own-if-10 "hej") "short")
      (assert-eq (own-if-10 "hejsansvejsan") "long")))


(defn own-if-11 (s)
  (if (< (strlen (ref s)) 10) "short" "long"))

(def own-ast-11 (lambda-to-ast (code own-if-11)))
(def own-con-11 (gencon own-ast-11))
(def own-asta-11 (annotate-ast own-ast-11))
(let [free (:free own-asta-11)]
  (do (assert-eq '(:arrow (:string) :string) (:type own-asta-11))
      (bake own-if-11)
      (assert-eq 1 (count free))
      (assert-eq "s" (:name (first free)))
      (assert-eq :string (:type (first free)))
      (assert-eq (own-if-11 "hej") "short")
      (assert-eq (own-if-11 "hejsansvejsan") "long")))


(defn own-if-12 (s)
  (if (< (strlen (ref s)) 10) s "too long"))

(def own-ast-12 (lambda-to-ast (code own-if-12)))
(def own-con-12 (gencon own-ast-12))
(def own-asta-12 (annotate-ast own-ast-12))
(let [free (:free own-asta-12)]
  (do (assert-eq '(:arrow (:string) :string) (:type own-asta-12))
      (bake own-if-12)
      (assert-eq 0 (count free))
      (assert-eq 1 (count (get-in own-asta-12 '(:body :free-right))))
      (assert-eq (own-if-12 "hej") "hej")
      (assert-eq (own-if-12 "hejsansvejsan") "too long")))


(defn own-if-13 (x)
  (if (= x 10) (str-append "a" "!") (str-append "b" "!")))

(def own-ast-13 (lambda-to-ast (code own-if-13)))
(def own-con-13 (gencon own-ast-13))
(def own-asta-13 (annotate-ast own-ast-13))
(let [free (:free own-asta-13)
      free-left (get-in own-asta-13 '(:body :free-left))
      free-right (get-in own-asta-13 '(:body :free-right))]
  (do (assert-eq '(:arrow (:int) :string) (:type own-asta-13))
      (bake own-if-13)
      (assert-eq 0 (count free))
      (assert-eq 2 (count free-left))
      (assert-eq 2 (count free-right))
      (assert-eq (own-if-13 10) "a!")
      (assert-eq (own-if-13 11) "b!")))


(defn own-if-13b (s)
  (if (< (strlen (ref s)) 10) (str-append "a" "!") (str-append "b" "!")))

(def own-ast-13b (lambda-to-ast (code own-if-13b)))
(def own-con-13b (gencon own-ast-13b))
(def own-asta-13b (annotate-ast own-ast-13b))
(let [free (:free own-asta-13b)
      free-left (get-in own-asta-13b '(:body :free-left))
      free-right (get-in own-asta-13b '(:body :free-right))]
  (do (assert-eq '(:arrow (:string) :string) (:type own-asta-13b))
      (bake own-if-13b)
      (assert-eq 1 (count free))
      (assert-eq 2 (count free-left))
      (assert-eq 2 (count free-right))
      (assert-eq (own-if-13b "short") "a!")
      (assert-eq (own-if-13b "loooooooooooooong") "b!")))


(defn own-binop-14 ()
  (+ (strlen "say") (strlen "what")))

(def own-ast-14 (lambda-to-ast (code own-binop-14)))
(def own-con-14 (gencon own-ast-14))
(def own-asta-14 (annotate-ast own-ast-14))
(let [free (:free own-asta-14)]
  (do (assert-eq '(:arrow () :int) (:type own-asta-14))
      (bake own-binop-14)
      (assert-eq 2 (count free))
      (assert-eq (own-binop-14) 7)))



(defn own-binop-15 (s)
  (str-append (itos (strlen "say")) (itos (strlen (ref s)))))

(def own-ast-15 (lambda-to-ast (code own-binop-15)))
(def own-con-15 (gencon own-ast-15))
(def own-asta-15 (annotate-ast own-ast-15))
(let [free (:free own-asta-15)]
  (do (assert-eq '(:arrow (:string) :string) (:type own-asta-15))
      (bake own-binop-15)
      (assert-eq 4 (count free)) ;; free "say", two itos results, and s
      (assert-eq (own-binop-15 "what") "34")
      (assert-eq (own-binop-15 "") "30")
      (assert-eq (own-binop-15 "whats the deal?") "315")))



(defn own-let-16 (s)
  (let [a "hello16"]
    (strlen (ref s))))

(def own-ast-16 (lambda-to-ast (code own-let-16)))
(def own-con-16 (gencon own-ast-16))
(def own-asta-16 (annotate-ast own-ast-16))
(let [free (:free own-asta-16)
      free-let (get-in own-asta-16 '(:body :free))
      ]
  (do (bake own-let-16)
      (assert-eq '(:arrow (:string) :int) (:type own-asta-16))
      (assert-eq 1 (count free)) ; free s
      (assert-eq 1 (count free-let))
      (assert-eq "a" (:name (first free-let)))
      (assert-eq (own-let-16 "x") 1)))



(defn own-let-17 ()
  (let [a "hello"]
    a))

(def own-ast-17 (lambda-to-ast (code own-let-17)))
(def own-con-17 (gencon own-ast-17))
(def own-asta-17 (annotate-ast own-ast-17))
(let [free (:free own-asta-17)
      free-let (get-in own-asta-17 '(:body :free))
      ]
  (do (bake own-let-17)
      (assert-eq '(:arrow () :string) (:type own-asta-17))
      (assert-eq 0 (count free))
      (assert-eq (own-let-17) "hello")))



(defn own-let-18 ()
  (let [a "hello"]
    (strlen a)))

(def own-ast-18 (lambda-to-ast (code own-let-18)))
(def own-con-18 (gencon own-ast-18))
(def own-asta-18 (annotate-ast own-ast-18))
(let [free (:free own-asta-18)
      free-let (get-in own-asta-18 '(:body :free))
      ]
  (do (bake own-let-18)
      (assert-eq '(:arrow () :int) (:type own-asta-18))
      (assert-eq 0 (count free))
      (assert-eq 1 (count free-let))
      (assert-eq "a" (:name (first free-let)))
      (assert-eq (own-let-18) 5)))



(defn own-let-19 ()
  (let [a "hello"]
    (eat-string a)))

(def own-ast-19 (lambda-to-ast (code own-let-19)))
(def own-con-19 (gencon own-ast-19))
(def own-asta-19 (annotate-ast own-ast-19))
(let [free (:free own-asta-19)
      free-let (get-in own-asta-19 '(:body :free))]
  (do (bake own-let-19)
      (assert-eq '(:arrow () :void) (:type own-asta-19))
      (assert-eq 0 (count free))
      (assert-eq 0 (count free-let))))



(defn own-while-20 (b)
  (while b
    (strlen "hej")))

(def own-ast-20 (lambda-to-ast (code own-while-20)))
(def own-con-20 (gencon own-ast-20))
(def own-asta-20 (annotate-ast own-ast-20))
(let [free (:free own-asta-20)
      free-while (get-in own-asta-20 '(:body :free))]
  (do (bake own-while-20)
      (assert-eq '(:arrow (:bool) :void) (:type own-asta-20))
      (assert-eq 0 (count free))
      (assert-eq 1 (count free-while))
      (assert-eq :string (:type (first free-while)))
      ))



(defn a-while ()
  (while true
    (println "what!")))



(defn own-while-21 (s)
  (while (< (strlen (ref s)) 10)
    (print "x")))

(def own-ast-21 (lambda-to-ast (code own-while-21)))
(def own-con-21 (gencon own-ast-21))
(def own-asta-21 (annotate-ast own-ast-21))
(let [free (:free own-asta-21)
      free-while (get-in own-asta-21 '(:body :free))]
  (do (bake own-while-21)
      (assert-eq '(:arrow (:string) :void) (:type own-asta-21))
      (assert-eq 1 (count free))
      (assert-eq 1 (count free-while))))




(defn own-do-22 (s)
  (do
    (strlen (ref s))
    (strlen (ref s))
    s))

(def own-ast-22 (lambda-to-ast (code own-do-22)))
(def own-con-22 (gencon own-ast-22))
(def own-asta-22 (annotate-ast own-ast-22))
(let [free (:free own-asta-22)]
  (do (bake own-do-22)
      (assert-eq '(:arrow (:string) :string) (:type own-asta-22))
      (assert-eq 0 (count free))
      (assert-eq (own-do-22 "hej") "hej")))



(defn own-do-23 (s)
  (do
    (eat-string s)
    123))

(def own-ast-23 (lambda-to-ast (code own-do-23)))
(def own-con-23 (gencon own-ast-23))
(def own-asta-23 (annotate-ast own-ast-23))
(let [free (:free own-asta-23)]
  (do (bake own-do-23)
      (assert-eq '(:arrow (:string) :int) (:type own-asta-23))
      (assert-eq 0 (count free))
      (assert-eq (own-do-23 "hej") 123)))


(defn own-do-24 (s)
  (do
    "Set me free!"
    (eat-string s)
    123))

(def own-ast-24 (lambda-to-ast (code own-do-24)))
(def own-con-24 (gencon own-ast-24))
(def own-asta-24 (annotate-ast own-ast-24))
(let [free (:free own-asta-24)]
  (do (bake own-do-24)
      (assert-eq '(:arrow (:string) :int) (:type own-asta-23))
      (assert-eq 1 (count free))
      (assert-eq (own-do-23 "hej") 123)))



(defn own-free-problem-25 ()
  (if true
    (let [x "hej"]
      (if (< 3 5) ;; got some problem with if here
        "yeah"
        "nope"))
    "gah"))

(def own-ast-25 (lambda-to-ast (code own-free-problem-25)))
(def own-con-25 (gencon own-ast-25))
(def own-asta-25 (annotate-ast own-ast-25))
(let [free (:free own-asta-25)]
  (do (bake own-free-problem-25)
      (assert-eq '(:arrow () :string) (:type own-asta-25))
      (assert-eq 0 (count free))
      (assert-eq 1 (count (get-in own-asta-25 '(:body :a :free)))) ;; free x
      (assert-eq (own-free-problem-25) "yeah")))


