
(def defmacro (macro (name args body)
                     (list 'do
                           (list 'def name (list 'macro args body))
                           (list 'meta-set! name :name (str name)))))

(defmacro when (expr a) (list 'if expr a nil))
(defmacro if-not (expr a b) (list 'if (list 'not expr) a b))
(defmacro comment (form) nil)

(defmacro assert-eq (a b)
  (list 'if-not (list '= a b)
	(list 'error (list 'str "assert-eq fail:\n" (str a) " \n=>\n " a "\n\n - VS - \n\n" (str b) " \n=>\n " b))
	nil))

(defmacro assert-error (error-code form)
  (list 'let ['result (list 'catch-error form)]
        (list 'if (list 'nil? 'result)
              (list 'error (list 'str "No error!\n" (str form) "\n=>\n" 'result))
              (list 'if-not (list '= error-code (list :error 'result))
                    (list 'error (list 'str "assert-error failed, expected error code " error-code " but got " (list :error 'result)))
                    :OK))))

(defmacro defn (name args body)
  (list 'do
        (list 'def name (list 'fn args body))
        (list 'meta-set! name :line (meta-get name :line))
        (list 'meta-set! name :user-defined true)))

(defn quasiquote-internal [form]  
  (match form
    ('dequote x) x

    ;; (x ... xs) (match x
    ;;              ('dequote-splicing inner-x) (concat (quasiquote-internal (eval inner-x)) (quasiquote-internal xs))
    ;;              _ (cons (quasiquote-internal x) (quasiquote-internal xs)))

    x (if (list? x)
        (cons 'list (map quasiquote-internal x))
        (list 'quote x))
    ))

(defmacro quasiquote (form)
  (quasiquote-internal form))

;; (defn quasiquote-internal [form]
;;   (do
;;     (println (str "form: " form))
;;     (if (list? form)
;;       (match form
;;         ('dequote x) x
;;         _ (map quasiquote-internal form))
;;       form)))

;; (defn replace-dequotes [form]
;;   (match form
;;     () ()
;;     ('dequote x) x
;;     (x ... xs) (cons (replace-dequotes x) (replace-dequotes xs))
;;     x x))

;; (defmacro quasiquote (form)
;;   (list 'quote (map replace-dequotes form)))

(defmacro assert (x)
  (list 'assert-eq true x))

(defn assert-approx-eq (target x)
  (do
    (assert-eq true (< x (+ target 0.1f)))
    (assert-eq true (< (- target 0.1f) x))))

(defn id (x) x)

(defn get-in (dict keys)
  (if (= () keys)
    dict
    (get-in (get dict (first keys)) (rest keys))))

(defn dict-set-in! (dict keys value)
  (if (= 1 (count keys))
    (dict-set! dict (first keys) value)
    (dict-set-in! (get dict (first keys)) (rest keys) value)))

(defn update-in! (dict key-path f)
  (dict-set-in! dict key-path (f (get-in dict key-path))))

(defn update-in (dict key-path f)
  (let [new (copy dict)]
    (do (update-in! new key-path f)
	new)))

(defn assoc (dict key val)
  (let [new (copy dict)]
    (do 
      (dict-set! new key val)
      new)))

(defn assoc-in (dict keys val)
  (let [new (copy dict)]
    (do 
      (dict-set-in! new keys val)
      new)))

(defn join (separator xs)
  (match (count xs)
    0 ""
    1 (str (first xs))
    _ (str (first xs) separator (join separator (rest xs)))))

(defn replicate (thing times)
  (if (< times 1)
    '()
    (cons thing (replicate thing (- times 1)))))

(defn repeatedly (f times)
  (if (< times 1)
    '()
    (cons (f) (repeatedly f (- times 1)))))

;; Replace all occurences of something in a list
(defn replace [the-list something replacement]
  (match the-list
    () ()
    (x ... xs) (if (= x something)
                 (cons replacement (replace xs something replacement))
                 (cons x (replace xs something replacement)))))

(def total-time 0)

(defmacro time (form)
  (list 'let ['t1 (list 'now)]
        (list 'let ['result form
                    't (list '- (list 'now) 't1)]
              (list 'do
                    (list 'println (list 'str "Evaluating form " (str form) " took " 't "ms."))
                    (list 'reset! 'total-time (list '+ 'total-time 't))
                    'result))))

(defmacro swap! (sym f)
  (list 'reset! sym (list f sym)))

(defn inc (x) (+ x 1))
(defn dec (x) (- x 1))

(defn contains? (items item)
  (match items
    () false
    (x ... xs) (if (= x item)
                 true
                 (contains? xs item))))

(defn any (pred xs)
  (contains? (map pred xs) true))

(defn true? (x) (if x true false))
(defn false? (x) (if x false true))

(defn log (message value)
  (do
    (println (str message value))
    value))

(defn nil? (x) (= nil x))
(defn not-nil? (x) (not (= nil x)))

(defn int? (x) (= :int (type x)))
(defn float? (x) (= :float (type x)))
(defn string? (x) (= :string (type x)))
(defn symbol? (x) (= :symbol (type x)))
(defn keyword? (x) (= :keyword (type x)))
(defn env? (x) (= :env (type x)))
(def dict? env?)
(defn list? (x) (= :list (type x)))
(defn array? (x) (= :array (type x)))
(defn macro? (x) (= :macro (type x)))
(defn lambda? (x) (= :lambda (type x)))
(defn foreign? (x) (= :foreign (type x)))
(defn primop? (x) (= :primop (type x)))

(defn function? (x) (or (lambda? x)
                        (foreign? x)
                        (primop? x)))

(defn range (start stop)
  (if (< start stop)
    (cons start (range (inc start) stop))
    '()))

(defn range-f (start stop step)
  (if (< start stop)
    (cons start (range-f (+ start step) stop step))
    '()))

(defn reverse (l)
  (match l
    () ()
    (x) (list x)
    (x ... xs) (cons-last (reverse xs) x)))

(defn has-key? (dict key)
  (not (= () (get-maybe dict key))))

(defn even? (x) (= 0 (mod x 2)))
(defn odd? (x) (= 1 (mod x 2)))

(defn last (xs)
  (match xs
    () (error "Can't call last on empty list.")
    (x) x
    _ (last (rest xs))))

(defn mapcat (f xs)
  (apply concat (map f xs)))

(def load load-lisp) ;; alias to allow inferior-lisp-mode to load file

(defn true? (x) (= true x))
(defn false? (x) (= false x))

(defn all? (pred xs)
  (= (count xs) (count (filter pred xs))))

(defn remove (pred xs)
  (filter (fn (x) (not (pred x))) xs))

(defn cons-unique (x xs)
  (if (contains? xs x)
    xs
    (cons x xs)))

(defn set-internal (xs ys)
  (match xs
    () ys
    (x ... xs) (set-internal xs (cons-unique x ys))
    (x) (cons-unique x ys)))

(defn set (xs)
  (set-internal xs '()))

(defn union (xs ys)
  (let [both (concat xs ys)]
    (set both)))

(defn intersection (xs ys)
  (match xs
    () ()
    (x ... xs) (if (contains? ys x)
                 (cons x (intersection xs ys))
                 (intersection xs ys))))

(defmacro for (b body)
  (match b
    (sym start limit) (list 'let [sym start]
                            (list 'while (list '< sym limit)
                                  (list 'do
                                        body
                                        (list 'reset! sym (list '+ sym 1)))))
    _ (error "Failed to match bindings in for loop.")))

(defn domap [f xs]
  (for (i 0 (count xs))
    (f (nth xs i))))

(defmacro str-ref (x)
  (list 'ref (list 'str x)))

(defn second [xs]
  (nth xs 1))

(defn third [xs]
  (nth xs 1))

(defn doc [x]
  (meta-get x :doc))


(defn template [text substitutions]
  (reduce (fn [t pair] (str-replace t (first pair) (str (second pair))))
          text
          (map2 list (keys substitutions) (values substitutions))))

(defn ls () (system "ls"))
(defn pwd () (system "pwd"))
(defn user () (getenv "USER"))
(defn mkdir (dir-name) (system (str "mkdir " dir-name)))
(defn touch (file-name) (system (str "touch " file-name)))

(register-builtin "platform" '() :int)

(def platform-osx 0)
(def platform-windows 1)
(def platform-linux 2)
(def platform-unknown 100)

(defn windows? []
  (= (platform) platform-windows))

(defn osx? []
  (= (platform) platform-osx))

(defn linux? []
  (= (platform) platform-linux))

(defmacro import (module-symbol)
  (list 'import-internal (str module-symbol)))
;;`(import-internal (name ~module-symbol))

(defn import-internal [module-name]
  (load-lisp (str carp-dir "lisp/" module-name ".carp")))
