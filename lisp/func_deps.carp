
;; vars-in-scope is a list of symbols
;; deps is a list of symbols refering to the functions that has to be baked for this function to work

(defn global? (vars-in-scope symbol)
  (not (contains? vars-in-scope symbol)))

(defn find-func-deps (ast bake-deps)
  (let [deps (copy '())

        _ (when (not (dict? ast)) (error (str "ast is not a dict: " ast)))
        _ (when (not (= :function (get-maybe ast :node))) (error (str "ast is not a function ast node: " ast)))
        
        func-name (let [n (get-maybe ast :name)] (if (nil? n) "" n))

        find-deps-in-list (fn (asts vars-in-scope)
                            (reduce (fn (result a) (cons-last result (find-func-deps-internal a vars-in-scope))) '() asts))

        find-deps-in-bindings (fn (bindings vars-in-scope)
                                (reduce (fn (result binding) (cons-last result (update-in binding '(:value) (fn (bv) (find-func-deps-internal bv vars-in-scope))))) '() bindings))

        find-func-deps-internal (fn (ast vars-in-scope)
                                  (do ;;(println (str "visit: " (:node ast)))
                                      (match (:node ast)

                                        :lookup (let [symbol (:value ast)
                                                      symbol-name (str symbol)
                                                      is-global-lookup (global? vars-in-scope symbol)
                                                      ;;_ (println (str "Comparing " func-name " with " symbol-name))
                                                      self-recursive (= func-name symbol-name)
                                                      is-constructor (= true (get-maybe ast :constructor))
                                                      ]
                                                  (if self-recursive
                                                    (assoc ast :self-recursive true)
                                                    (do
                                                      (when is-global-lookup
                                                        (let [evaled (eval symbol)
                                                              is-primop (primop? evaled)
                                                              is-lambda (lambda? evaled)
                                                              is-function (function? evaled)]
                                                          (do
                                                            (when (and (not is-function) (not is-constructor))
                                                              (do
                                                                ;;(println (str symbol " is not a function/constructor, make it a global variable."))
                                                                (bake-global (name symbol))
                                                                (reset! deps (cons symbol deps))))
                                                            (when is-constructor
                                                              (do
                                                                (reset! deps (cons symbol deps))))
                                                            (when (and is-lambda bake-deps) ;; Bake, then add to deps
                                                              (do
                                                                ;;(println (str symbol " is a dependency of " func-name ", code: " (code evaled)))
                                                                (bake-internal (str symbol)
                                                                               (code evaled)
                                                                               (meta-get evaled :ann)
                                                                               '()
                                                                               false)
                                                                (reset! deps (cons symbol deps))))
                                                            (when (and (foreign? evaled))
                                                              (reset! deps (cons symbol deps)))
                                                            )))                                                      
                                                      (assoc ast :global-lookup is-global-lookup))))

                                        :reset (let [ast0 (update-in ast '(:expr) (fn (a) (find-func-deps-internal a vars-in-scope)))
                                                     ast1 (update-in ast0 '(:symbol) (fn [a] (find-func-deps-internal a vars-in-scope)))]
                                                 ast1)

                                        :app (let [ast0 (update-in ast '(:head) (fn (a) (find-func-deps-internal a vars-in-scope)))
                                                   ast1 (update-in ast0 '(:tail) (fn (a) (find-deps-in-list a vars-in-scope)))]
                                               ast1)
                                        
                                        :function (let [args (:args ast)
                                                        new-vars (union (map :name args) vars-in-scope)
                                                        ;;_ (println (str "new-vars: " new-vars))
                                                        ]
                                                    (update-in ast '(:body) (fn (a) (find-func-deps-internal a new-vars))))

                                        :if (let [ast0 (update-in ast  '(:expr) (fn (a) (find-func-deps-internal a vars-in-scope)))
                                                  ast1 (update-in ast0 '(:if-true) (fn (a) (find-func-deps-internal a vars-in-scope)))
                                                  ast2 (update-in ast1 '(:if-false) (fn (a) (find-func-deps-internal a vars-in-scope)))]
                                              ast2)

                                        :while (let [ast0 (update-in ast  '(:expr) (fn (a) (find-func-deps-internal a vars-in-scope)))
                                                     ast1 (update-in ast0 '(:body) (fn (a) (find-func-deps-internal a vars-in-scope)))]
                                              ast1)

                                        :binop (let [ast0 (update-in ast  '(:left) (fn (a) (find-func-deps-internal a vars-in-scope)))
                                                     ast1 (update-in ast0 '(:right) (fn (a) (find-func-deps-internal a vars-in-scope)))]
                                                 ast1)

                                        :literal ast

                                        :do (let [new-ast (update-in ast '(:forms) (fn (a) (find-deps-in-list a vars-in-scope)))]
                                              new-ast)

                                        :let (let [;;_ (println (str "ast:\n" ast))
                                                   bindings (:bindings ast)
                                                   new-vars (union (map :name bindings) vars-in-scope)
                                                   ast0 (assoc ast :bindings (find-deps-in-bindings bindings new-vars))
                                                   ;;_ (println (str "ast0:\n" ast0))
                                                   ]
                                               (update-in ast0 '(:body) (fn (a) (find-func-deps-internal a new-vars))))

                                        :ref (let [ast0 (update-in ast '(:expr) (fn (a) (find-func-deps-internal a vars-in-scope)))]
                                               ast0)

                                        ;; (if (= :lookup (get-in ast0 '(:expr :node)))
                                        ;;          (assoc ast0 :ref-dep (str (get-in ast0 '(:expr :value)))) ;; this ref is depending on another variable
                                        ;;          ast0)

                                        :null ast

                                        :array (let [;;_ (println (str ":array " ast))
                                                     ast0 (update-in ast '(:values) (fn (a) (find-deps-in-list a vars-in-scope)))]
                                                 ast0)

                                        x (error (str "find-func-deps can't handle node: " x))
                                        
                                        )))
        
        new-ast (find-func-deps-internal ast '())]
    (assoc new-ast :func-deps deps)))

(defn type-of-global [global-variable-name]
  (let [s (symbol global-variable-name)
        tt (eval (list 'type s))
        t (if (= :ptr tt)
            (eval (list 'meta-get s :type))
            tt)]
    t))

(defn bake-global [variable-name]
  (let [t (type-of-global variable-name)
        evaled (eval (symbol variable-name))        
        ;;_ (println (str variable-name " has type " t))
        c-variable-name (c-ify-name variable-name)]
    (if (contains? '(:int :float :double :string) t)
      (do
        ;;(println (str "Adding global named " variable-name " of type " t))
        (let [prototype (str "extern " (type-build t) " " c-variable-name ";")
              c-code (str (type-build t) " " c-variable-name " = " (prn evaled) ";")
              includes-string "#include <shared.h>\n\n"
              deps '()]
          (do
            (bake-c-code variable-name t c-variable-name (str out-dir c-variable-name ".c") c-code includes-string prototype deps false)
            ;;(add-global! variable-name prototype)
            )))
      (error (str "Can't handle globals of type " t " yet.")))))
