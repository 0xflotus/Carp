
(defn generic-safe-name (t)
  (match t
         (:fn args ret) (str "Fn-" (join "" (map generic-safe-name args)) "-" (generic-safe-name ret))
         (:ref r) (str "RefTo-" (generic-safe-name r) "")
         (:Array a) (str "ArrayOf-" (generic-safe-name a) "")
         x (if (keyword? t)
             (name t)
             (error (str "generic-safe-name can't handle type signature: " t)))))


(defn generic-suffix (signature)
  (str (join "-" (map generic-safe-name (nth signature 1)))
       "-"
       (generic-safe-name (nth signature 2))))

(defn generic-name [base-name signature]
  (do
    ;;(println (str "Will find generic name for " base-name " with signature " signature))
    (str base-name "--" (generic-suffix signature))))

(defn visit-generic-funcs [ast]
  (let [deps (copy (:func-deps ast))

        visit-lookup (fn [ast]
                       (let [t (:type ast)]
                         (do
                           ;;(println (str (:value ast) " : " t))
                           (if (and (nil? (get-maybe ast :self-recursive)) (:global-lookup ast))
                             (let [lookup-sym (:value ast)
                                   ;;_ (println (str "Will eval " ast))
                                   global-lookup (eval lookup-sym)
                                   lookup-t (type global-lookup)
                                   ;;_ (println (str "lookup-t: " lookup-t))
                                   is-generic (meta-get lookup-t :generic)
                                   ]
                               (if (and (lambda? global-lookup) is-generic)
                                 (if (generic-type? t)
                                   (do ;;(println (str "Lambda with missing type information, can't compile concrete version: " t))
                                       ast)
                                   (let [n (generic-name lookup-sym t)]
                                     (do
                                       ;;(println (str "generic lookup of '" lookup-sym "', t: " t ", lookup-t: " lookup-t ", n: " generic-name))
                                       (bake-generic-func-internal (new-builder)
                                                                   n
                                                                   (code global-lookup)
                                                                   '()
                                                                   false
                                                                   t)
                                       (reset! deps (cons (symbol n) deps))
                                       (let [ast0 (assoc-in ast '(:value) (symbol n))] ;; make it call another function...
                                         ast0))))
                                 (if (and (primop? global-lookup) is-generic)
                                   (if (generic-type? t)
                                     (do ;;(println (str "Primop with missing type information, can't compile concrete version: " t))
                                         ast)
                                     (let [n (generic-name lookup-sym t)]
                                       (do
                                         ;;(println (str "Found a generic primop to bake: " lookup-sym))
                                         ;; (println (str "Final name will be " n))
                                         (bake-generic-primop (new-builder)
                                                              n
                                                              (str lookup-sym)
                                                              t)
                                         (reset! deps (cons (symbol n) deps))
                                         (assoc-in ast '(:value) (symbol n)))))
                                   ast)))
                             ast))))

        visit-generic-funcs-internal (fn [ast]
                                       (match (:node ast)
                                         :function (update-in ast '(:body) visit-generic-funcs-internal)
                                         :app (let [ast0 (update-in ast '(:head) visit-generic-funcs-internal) ;; todo: use a here
                                                    ast1 (update-in ast0 '(:tail) (fn (a) (map visit-generic-funcs-internal (:tail ast))))]
                                                ast1)
                                         :lookup (visit-lookup ast)

                                         :if (let [ast0 (update-in ast '(:expr) visit-generic-funcs-internal)
                                                   ast1 (update-in ast0 '(:if-true) visit-generic-funcs-internal)
                                                   ast2 (update-in ast1 '(:if-false) visit-generic-funcs-internal)]
                                               ast2)

                                         :binop (let [ast0 (update-in ast '(:left) visit-generic-funcs-internal)
                                                      ast1 (update-in ast0 '(:right) visit-generic-funcs-internal)]
                                                  ast1)

                                         :reset (let [ast0 (update-in ast '(:expr) visit-generic-funcs-internal)]
                                                  ast0)

                                         :literal ast

                                         :ref (update-in ast '(:expr) visit-generic-funcs-internal)

                                         :let (let [ast0 (update-in ast '(:bindings)
                                                                    (fn [forms] (map visit-generic-funcs-internal forms)))]
                                                (update-in ast0 '(:body) visit-generic-funcs-internal))

                                         :binding (update-in ast '(:value) visit-generic-funcs-internal)

                                         :while (let [ast0 (update-in ast '(:expr) visit-generic-funcs-internal)
                                                      ast1 (update-in ast0 '(:body) visit-generic-funcs-internal)]
                                                  ast1)

                                         :null ast

                                         :do (update-in ast '(:forms) (fn [forms] (map visit-generic-funcs-internal forms)))
                                         
                                         x (error (str "visit-generic can't handle node type " x))))]
    (assoc (visit-generic-funcs-internal ast) :func-deps deps)))


;; The easy version of bake-generic-primop, used to ensure that a certain instance of a generic function exists
;; For example, to ensure that 'nth' (a primop) exists for float arrays, call this function like this:
;;  (bake-generic-primop-auto "nth" '(:fn ((:ref (:Array :float)) :int) :float))
;; This will generate the function nth--RefTo-ArrayOf-float-int-float of type (&Array float, int) -> float
(defn bake-generic-primop-auto [primop-name signature]
  (let [builder (new-builder)
        func-name (generic-name (symbol primop-name) signature)]
    (bake-generic-primop builder func-name primop-name signature)))


;; Used by the visit-generic-func algorithm to generate and register baked version of generic primops
(defn bake-generic-primop [builder func-name primop-name signature]
  (let [c-func-name (c-ify-name func-name)
        c-file-name (str out-dir c-func-name ".c")]
    (if (func-baked? func-name)
      (do
        ;;(println (str "Ignoring already baked generic primop: " func-name))
        nil)
      (let [result (build-generic-primop c-func-name primop-name signature)
            c-program-string (str "#include <shared.h>\n#include \"functions.h\"\n" (:c result))
            proto (str (:proto result) ";")
            deps (:deps result)
            ]
        (do
          (def c c-program-string)
          ;; (println (str "Baking generic primop " func-name))
          ;; (println (str "Prototype for " func-name ":\n" proto))
          ;; (println (str "C-code for " func-name ":\n" c-program-string))
          (save-and-compile func-name signature c-func-name c-file-name c-program-string proto deps false))))))


(defn build-generic-primop [c-func-name primop-name signature]
  (match primop-name

    "" (match signature
            (:fn () )
            (let [proto (str)
                  c (str)]
              {:proto proto :c c :deps ()})
            _ (error "Invalid type for call to ''"))

    ;; "new" (match signature
    ;;         (:fn arg-types :t)
    ;;         (let [proto (str (type-build t) " " c-func-name "(" (string-join ", " (map (fn (arg)) arg-types)) ")")
    ;;               c (str proto " { return NULL; }")]
    ;;           {:proto proto :c c :deps ()})
    ;;         _ (error "Invalid type for call to 'new'"))

    "map" (match signature
            (:fn ((:fn (a) a) (:Array a)) (:Array a)) (let [proto (str "API " (type-build (list :Array a)) " " c-func-name "(" (type-build (list :fn (list a) a)) " f, Array *array)")
                                                            c (str proto
                                                                   "{ \n"
                                                                   "  int count = array->count;\n"
                                                                   "  " (type-build a) "* casted = array->data;\n" 
                                                                   "  for(int i = 0; i < count; i++) {\n"
                                                                   "    casted[i] = f(casted[i]);\n"
                                                                   "  }\n"
                                                                   "  array->data = casted;"
                                                                   "  return array;\n"
                                                                   "}")]
                                                        {:proto proto :c c :deps ()})
            x (error (str "Invalid type for call to 'map': " x)))

    "map-copy" (match signature
            (:fn ((:fn (a) b) (:Array a)) (:Array b)) (let [proto (str "API " (type-build (list :Array b)) " " c-func-name "(" (type-build (list :fn (list a) b)) " f, Array *array)")
                                                            array-of-size-sig (list :fn (list :int) (list :Array b))
                                                            _ (bake-generic-primop-auto "array-of-size" array-of-size-sig)
                                                            array_of_size_call (generic-name "array-of-size" array-of-size-sig)
                                                            _ (println array_of_size_call)
                                                            c (str proto
                                                                   "{ \n"
                                                                   "  int count = array->count;\n"
                                                                   "  " (type-build a) "* casted = array->data;\n"
                                                                   "  Array* new_array = " (c-ify-name array_of_size_call) "(count);\n"
                                                                   "  " (type-build b) "* new_casted = new_array->data;\n"
                                                                   "  for(int i = 0; i < count; i++) {\n"
                                                                   "    new_casted[i] = f(casted[i]);\n"
                                                                   "  }\n"
                                                                   "  free(array);\n"
                                                                   "  return new_array;\n"
                                                                   "}")]
                                                        {:proto proto :c c :deps (list array_of_size_call)})
            x (error (str "Invalid type for call to 'map-copy': " x)))
    
    "str" (do
            ;;(println (str "Calling str for signature: " signature))
            (match signature
              (:fn ((:ref (:Array t))) :string) (instantiate-str-for-array c-func-name t)
              
              (:fn (:int) :string) (let [proto (str "API string " c-func-name "(int x)")
                                         c (str proto " { return itos(x); }")]
                                     {:proto proto :c c :deps ()})

              (:fn (:float) :string) (let [proto (str "API string " c-func-name "(float x)")
                                           c (str proto " { "
                                                  " char output[50];"
                                                  " snprintf(output, 50, \"%f\", x);"
                                                  " return strdup(output);"
                                                  "}")]
                                       {:proto proto :c c :deps ()})

              (:fn ((:ref :string)) :string) (instantiate-str-for-string c-func-name)
              (:fn (:string) :string) (instantiate-str-for-string c-func-name)

              (:fn ((:ref maybe-struct-type)) :string) (instantiate-str-for-struct c-func-name maybe-struct-type)
              (:fn (maybe-struct-type) :string) (instantiate-str-for-struct c-func-name maybe-struct-type)
              
              x (error (str "Invalid type for call to 'str': " x))))

    "delete" (do
               (match signature
                 (:fn ((:Array t)) :string) (instantiate-delete-for-array c-func-name t)
                 (:fn (:string) :string) (instantiate-delete-for-string c-func-name)
                 (:fn (maybe-struct-type) :string) (instantiate-delete-for-struct c-func-name maybe-struct-type)
                 x (error (str "Invalid type for call to 'delete': " x))))

    "copy" (do
               (match signature
                 ;;(:fn ((:ref (:Array t))) t) (instantiate-copy-for-array c-func-name t)
                 (:fn ((:ref :string)) :string) (instantiate-copy-for-string c-func-name)
                 ;;(:fn (:string) :string) (instantiate-copy-for-string c-func-name)
                 (:fn ((:ref maybe-struct-type)) maybe-struct-type) (instantiate-copy-for-struct c-func-name maybe-struct-type)
                 x (error (str "Invalid type for call to 'copy': " x))))
    
    "nth" (match signature
            (:fn ((:ref (:Array t)) :int) t)
            (let [proto (str "API " (type-build t) " " c-func-name "(Array *a, int index)")
                  c (str proto " { return ((" (type-build t) "*)(a->data))[index]; }")]
              {:proto proto :c c :deps ()})
            _ (error "Invalid type for call to 'nth'"))

    
    "array-of-size" (match signature
                      (:fn (:int) (:Array t))
                      (let [proto (str "API " (type-build '(:Array t)) " " c-func-name "(int count)")
                            c (str proto
                                   "{ Array *a = malloc(sizeof(Array));"
                                   " a->count = count;"
                                   " a->data = calloc(count, sizeof(" (type-build t) "));"
                                   " return a;"
                                   " }")]
                        {:proto proto :c c :deps ()})
                      x (error (str "Invalid type for call to 'array-of-size': " x)))

    
    "array-set" (match signature
                  (:fn ((:Array t) :int t) (:Array t))
                  (let [proto (str "API " (type-build '(:Array t)) " " c-func-name "(Array *a, int index, " (type-build t) " value)")
                        c (str proto " { ((" (type-build t) "*)(a->data))[index] = value; return a; }")]
                    {:proto proto :c c :deps ()})
                  _ (error "Invalid type for call to 'array-set'"))


    x (error (str "Can't build generic primop for '" x "'"))))


(defn instantiate-str-for-string [c-func-name]
  (let [proto (str "API string " c-func-name "(string s)")
        c (str proto " { "
               " int len = strlen(s);"
               " int new_len = len + 3;"
               " char *new_s = malloc(sizeof(char) * new_len);"
               " memcpy(new_s + 1, s, len); "
               " new_s[0] = '\"';"
               " new_s[new_len - 2] = '\"';"
               " new_s[new_len - 1] = '\\0';"
               " return new_s;"
               "}")]
    {:proto proto :c c :deps ()}))

(defn instantiate-str-for-struct [c-func-name maybe-struct-type]
  (if (keyword? maybe-struct-type)
    (let [_ (when (or (= :string maybe-struct-type)
                      (primitive-type? maybe-struct-type))
              (error (str "Primitive type sent to 'str' instantiator for struct types, but it is not a struct type: " maybe-struct-type)))
          lookup (eval (symbol (name maybe-struct-type)))]
      (if (and (dict? lookup) (= true (get-maybe lookup :struct)))
        (let [t-name (name maybe-struct-type)
              proto (str "string " c-func-name "(" t-name " *x)")
              member-names (array-to-list (:member-names lookup))
              member-types (array-to-list (:member-types lookup))
              ;;_ (build-constructor t-name member-names member-types) ;; build the constructor type to make it accessible to this function
              c (str proto " { "
                     " char buffer[1024];\n"
                     " int pos = 0;\n"
                     " buffer[pos++] = '(';\n"
                     " snprintf(buffer + pos, 1000, \"%s\", \"" t-name "\");"
                     " pos += " (strlen t-name) ";"
                     " buffer[pos++] = ' ';\n"
                     " char *s;"
                     (join " " (map2 (fn [t n]
                                       (do
                                         (bake-generic-primop-auto "str" (list :fn (list t) :string))
                                         (str "
s = str__" (type-build t) "_string(x->" n "); 
snprintf(buffer + pos, 1000, \"%s\", s); pos += strlen(s); buffer[pos++] = ' '; ")))
                                     member-types
                                     member-names))
                     " pos--;"
                     " buffer[pos++] = ')';\n"
                     " buffer[pos++] = '\\0';\n"
                     " return strdup(buffer);\n"
                     ;;"return \"" t-name "\"; "
                     "}")]
          {:proto proto
           :c c
           :deps (map (fn [t] (str "str__" (type-build t) "_string")) member-types)})
        (error (str "Invalid (non-struct) type for call to 'str': " maybe-struct-type "\n" lookup))))
    (error (str "Invalid type for call to 'str': " maybe-struct-type))))

(defn instantiate-str-for-array [c-func-name t]
  (let [proto (str "API string " c-func-name "(Array *a)")
        ;; Call str without ref for primitive types, otherwise use ref
        inner-arg-type (if (primitive-type? t) t (list :ref t))
        inner-signature (list :fn (list inner-arg-type) :string)
        inner-str-call (c-ify-name (generic-name (symbol "str") inner-signature))
        _ (bake-generic-primop-auto "str" inner-signature)
        ;;_ (println (str "inner-str-call: " inner-str-call))
        c (str proto
               "{"
               " char buffer[1024];\n"
               " int pos = 0;\n"
               " int count = a->count;\n"
               " buffer[pos++] = '[';\n"
               " " (type-build t) " *casted_data = a->data;\n"
               " for(int i = 0; i < count; i++) {\n"
               ;;"   printf(\"%d \", casted_data[i]);\n"
               "   char *inner_str = " inner-str-call "(casted_data[i]);\n"
               "   snprintf(buffer + pos, 1024 - pos - 1,\"%s\", inner_str);\n"
               "   pos += strlen(inner_str);\n"
               "   if(i < count - 1) {"
               "     buffer[pos++] = ',';\n"
               "     buffer[pos++] = ' ';\n"
               "   }"
               " }"
               " buffer[pos++] = ']';\n"
               " buffer[pos++] = '\\0';\n"
               " return strdup(buffer);\n"
               "}")]
    {:proto proto :c c :deps (list inner-str-call)}))



(defn instantiate-copy-for-string [c-func-name]
  (let [;;_ (println (str "instantiate " c-func-name))
        proto (str "API string " c-func-name "(string s)")
        c (str proto " { return strdup(s); }")]
    {:proto proto :c c :deps ()}))

(defn instantiate-copy-for-struct [c-func-name maybe-struct-type]
  (if (keyword? maybe-struct-type)
    (let [_ (when (or (= :string maybe-struct-type)
                      (primitive-type? maybe-struct-type))
              (error (str "Primitive type sent to 'copy' instantiator for struct types, but it is not a struct type: " maybe-struct-type)))
          lookup (eval (symbol (name maybe-struct-type)))]
      (if (and (dict? lookup) (= true (get-maybe lookup :struct)))
        (let [t-name (name maybe-struct-type)
              proto (str t-name " *" c-func-name "(" t-name " *x)")
              _ (println (str "proto for struct copying function: " proto))
              member-names (array-to-list (:member-names lookup))
              member-types (array-to-list (:member-types lookup))
              c (str proto " { \n"
                     "  " (type-build maybe-struct-type) " x_copy = calloc(1, sizeof(" t-name "));\n"
                     (join " " (map2 (fn [t n]
                                       (if (primitive-type? t)
                                         (str "  x_copy->" n " = x->" n ";\n")
                                         (let [inner-copy-sig (list :fn (list (list :ref t)) t)
                                               copy-function-c-name (str "copy__" (c-ify-name (generic-safe-name (list :ref t))) "_" (type-build t))]
                                           (do
                                             (bake-generic-primop-auto "copy" inner-copy-sig)
                                             (str "x_copy->" n " = " copy-function-c-name "(x->" n ");\n")))))                                           
                                     member-types
                                     member-names))
                     "  return x_copy;\n"
                     "}\n")]
          {:proto proto
           :c c
           :deps (map (fn [t] (str "copy__" (c-ify-name (generic-safe-name (list :ref t))) "_" (type-build t))) (remove primitive-type? member-types))})
        (error (str "Invalid (non-struct) type for call to 'str': " maybe-struct-type "\n" lookup))))
    (error (str "Invalid type for call to 'str': " maybe-struct-type))))
