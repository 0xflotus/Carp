;; ;; t is the complete type
;; ;; o is the original type with typevars (represented as strings)
;; (defn better-generic-name [t o]
;;   nil)

;; (defn extract-typevars [o]
;;   (if (list? o)
;;     (set (mapcat extract-typevars o))
;;     (if (string? o)
;;       (list o)
;;       ())))

(defn generic-safe-name [t]
  (match t
    () ""
    (x ... xs) (str (generic-safe-name x) "<" (join "-" (map generic-safe-name xs)) ">")
    x (if (keyword? x)
        (name t)
        (error (str "generic-safe-name can't handle type signature: " t)))))

;; (match t
;;     (:fn args ret) (str "Fn-" (join "" (map generic-safe-name args)) "-" (generic-safe-name ret))
;;     (:ref r) (str "RefTo-" (generic-safe-name r) "")
;;     (:Array a) (str "ArrayOf-" (generic-safe-name a) "")
;;     x (if (keyword? t)
;;         (name t)
;;         (error (str "generic-safe-name can't handle type signature: " t))))

(defn generic-suffix [signature]
  (str (join "-" (map generic-safe-name (nth signature 1)))
       "-"
       (generic-safe-name (nth signature 2))))

(defn generic-name [base-name signature]
  (do
    ;;(println (str "Will find generic name for " base-name " with signature " signature))
    (str base-name "--" (generic-suffix signature))))



;; Used for let polymorphism to make the generic type of a function unique (i.e. change all the "T":s to a fresh typevar)
;; (:fn ("T" "S") "T") becomes (:f ("t319" "t302") "t319)
(defn uniquify-typevars [t]
  (uniquify-typevars-internal t (copy {})))

(defn uniquify-typevars-internal [t substs]
  (if (string? t)
    (let [existing-tvar (get-maybe substs t)]
      (if (nil? existing-tvar)
        (let [new-tvar (gen-typevar)]
          (do                          
            (dict-set! substs t new-tvar)
            new-tvar))
        existing-tvar))
    (if (keyword? t)
      t
      (if (list? t)
        (map (fn [x] (uniquify-typevars-internal x substs)) t)
        (error (str "Can't handle t " t " of type " (type t)))))))



(defn visit-generic-funcs [ast]
  (let [deps (copy (:func-deps ast))

        visit-lookup (fn [ast]
                       (let [t (:type ast)]
                         (do
                           ;;(println (str (:value ast) " : " t))
                           (if (and (nil? (get-maybe ast :self-recursive)) (:global-lookup ast))
                             (let [lookup-sym (:value ast)
                                   ;;_ (println (str "Will eval " ast))
                                   global-lookup (eval lookup-sym)
                                   lookup-t (type global-lookup)
                                   ;;_ (println (str "lookup-t: " lookup-t))
                                   is-generic (meta-get lookup-t :generic)
                                   ]
                               (if (and (lambda? global-lookup) is-generic)
                                 (if (generic-type? t)
                                   (do
                                     ;;(println (str "Lambda with missing type information, can't compile concrete version: " lookup-sym " of type " t))
                                     ast)
                                   (let [n (generic-name lookup-sym t)]
                                     (do
                                       ;;(println (str "generic lookup of '" lookup-sym "', t: " t ", lookup-t: " lookup-t ", n: " generic-name))
                                       (bake-generic-func-internal n
                                                                   (code global-lookup)
                                                                   '()
                                                                   false
                                                                   t)
                                       (reset! deps (cons (symbol n) deps))
                                       (let [ast0 (assoc-in ast '(:value) (symbol n))] ;; make it call another function...
                                         ast0))))
                                 (if (and (primop? global-lookup) is-generic)
                                   (if (generic-type? t)
                                     (do ;;(println (str "Primop with missing type information, can't compile concrete version: " t))
                                       ast)
                                     (let [n (generic-name lookup-sym t)]
                                       (do
                                         ;;(println (str "Found a generic primop to bake: " lookup-sym))
                                         ;; (println (str "Final name will be " n))
                                         (bake-generic-primop n
                                                              (str lookup-sym)
                                                              t)
                                         (reset! deps (cons (symbol n) deps))
                                         (assoc-in ast '(:value) (symbol n)))))
                                   ast)))
                             ast))))

        visit-generic-funcs-internal (fn [ast]
                                       (match (:node ast)
                                         :function (update-in ast '(:body) visit-generic-funcs-internal)
                                         :app (let [ast0 (update-in ast '(:head) visit-generic-funcs-internal) ;; todo: use a here
                                                    ast1 (update-in ast0 '(:tail) (fn (a) (map visit-generic-funcs-internal (:tail ast))))]
                                                ast1)
                                         :lookup (visit-lookup ast)

                                         :if (let [ast0 (update-in ast '(:expr) visit-generic-funcs-internal)
                                                   ast1 (update-in ast0 '(:if-true) visit-generic-funcs-internal)
                                                   ast2 (update-in ast1 '(:if-false) visit-generic-funcs-internal)]
                                               ast2)

                                         :binop (let [ast0 (update-in ast '(:left) visit-generic-funcs-internal)
                                                      ast1 (update-in ast0 '(:right) visit-generic-funcs-internal)]
                                                  ast1)

                                         :reset (let [ast0 (update-in ast '(:expr) visit-generic-funcs-internal)]
                                                  ast0)

                                         :literal ast

                                         :ref (update-in ast '(:expr) visit-generic-funcs-internal)

                                         :let (let [ast0 (update-in ast '(:bindings)
                                                                    (fn [forms] (map visit-generic-funcs-internal forms)))]
                                                (update-in ast0 '(:body) visit-generic-funcs-internal))

                                         :binding (update-in ast '(:value) visit-generic-funcs-internal)

                                         :while (let [ast0 (update-in ast '(:expr) visit-generic-funcs-internal)
                                                      ast1 (update-in ast0 '(:body) visit-generic-funcs-internal)]
                                                  ast1)

                                         :null ast

                                         :array (update-in ast '(:values) (fn [vals] (map visit-generic-funcs-internal vals)))

                                         :do (update-in ast '(:forms) (fn [forms] (map visit-generic-funcs-internal forms)))
                                         
                                         x (error (str "visit-generic can't handle node type " x))))]
    (assoc (visit-generic-funcs-internal ast) :func-deps deps)))


;; The easy version of bake-generic-primop, used to ensure that a certain instance of a generic function exists
;; For example, to ensure that 'nth' (a primop) exists for float arrays, call this function like this:
;;  (bake-generic-primop-auto "nth" '(:fn ((:ref (:Array :float)) :int) :float))
;; This will generate the function nth--RefTo-ArrayOf-float-int-float of type (&Array float, int) -> float
(defn bake-generic-primop-auto [primop-name signature]
  (let [func-name (generic-name (symbol primop-name) signature)]
    (bake-generic-primop func-name primop-name signature)))


;; Used by the visit-generic-func algorithm to generate and register baked version of generic primops
(defn bake-generic-primop [func-name primop-name signature]
  (let [c-func-name (c-ify-name func-name)
        c-file-name (str out-dir c-func-name ".c")]
    (if (func-baked? func-name)
      (do
        ;;(println (str "Ignoring already baked generic primop: " func-name))
        nil)
      (let [result (build-generic-primop c-func-name primop-name signature)
            includes-string (str "#include <shared.h>\n#include \"declarations.h\"\n")
            c-program-string (:c result)
            proto (str (:proto result) ";")
            deps (:deps result)
            ]
        (do
          (def c c-program-string)
          ;;(println (str "Baking generic primop " func-name))
          ;; (println (str "Prototype for " func-name ":\n" proto))
          ;; (println (str "C-code for " func-name ":\n" c-program-string))
          (bake-c-code func-name signature c-func-name c-file-name c-program-string includes-string proto deps false))))))


(defn build-generic-primop [c-func-name primop-name signature]
  (match primop-name

    "" (match signature
         (:fn () )
         (let [proto (str)
               c (str)]
           {:proto proto :c c :deps ()})
         _ (error "Invalid type for call to ''"))

    "map" (match signature
            (:fn ((:fn (a) a) (:Array a)) (:Array a)) (let [proto (str "API " (type-build (list :Array a)) " " c-func-name "(" (type-build (list :fn (list a) a)) " f, Array *array)")
                                                            c (str proto
                                                                   "{ \n"
                                                                   "  int count = array->count;\n"
                                                                   "  " (type-build a) "* casted = array->data;\n" 
                                                                   "  for(int i = 0; i < count; i++) {\n"
                                                                   "    casted[i] = f(casted[i]);\n"
                                                                   "  }\n"
                                                                   "  array->data = casted;"
                                                                   "  return array;\n"
                                                                   "}")]
                                                        {:proto proto :c c :deps ()})
            x (error (str "Invalid type for call to 'map': " x)))

    ;; TODO: can this be a normal function now?
    "map-copy" (match signature
                 (:fn ((:fn (a) b) (:ref (:Array a))) (:Array b)) (let [proto (str "API " (type-build (list :Array b)) " " c-func-name "(" (type-build (list :fn (list a) b)) " f, Array *array)")
                                                                 array-of-size-sig (list :fn (list :int) (list :Array b))
                                                                 _ (bake-generic-primop-auto "array-of-size" array-of-size-sig)
                                                                 array_of_size_call (generic-name "array-of-size" array-of-size-sig)
                                                                 ;;_ (println array_of_size_call)
                                                                 c (str proto
                                                                        "{ \n"
                                                                        "  int count = array->count;\n"
                                                                        "  " (type-build a) "* casted = array->data;\n"
                                                                        "  Array* new_array = " (c-ify-name array_of_size_call) "(count);\n"
                                                                        "  " (type-build b) "* new_casted = new_array->data;\n"
                                                                        "  for(int i = 0; i < count; i++) {\n"
                                                                        "    new_casted[i] = f(casted[i]);\n"
                                                                        "  }\n"
                                                                        ;;"  free(array);\n"
                                                                        "  return new_array;\n"
                                                                        "}")]
                                                             {:proto proto :c c :deps (list array_of_size_call)})
                 x (error (str "Invalid type for call to 'map-copy': " x)))
    
    "str" (do
            ;;(println (str "Calling str for signature: " signature))
            (match signature

              (:fn ((:ref :Array)) :string) (error "Can't instantiate 'str' for :Array with no type variable.")

              (:fn ((:ref (:Array t))) :string) (instantiate-str-for-array c-func-name t)

              (:fn ((:ref :int)) :string) (let [proto (str "API string " c-func-name "(int x)")
                                                c (str proto " { return itos(x); }")]
                                            {:proto proto :c c :deps ()})
              (:fn (:int) :string) (let [proto (str "API string " c-func-name "(int x)")
                                         c (str proto " { return itos(x); }")]
                                     {:proto proto :c c :deps ()})

              (:fn (:char) :string) (let [proto (str "API string " c-func-name "(char x)")
                                          c (str proto " { string s = malloc(3); s[0] = '\\\\'; s[1] = x; return s; }")]
                                      {:proto proto :c c :deps ()})

              (:fn (:bool) :string) (let [proto (str "API string " c-func-name "(bool b)")
                                          c (str proto " { if(b) { return strdup(\"true\"); } else { return strdup(\"false\"); } }")]
                                      {:proto proto :c c :deps ()})

              (:fn (:float) :string) (let [proto (str "API string " c-func-name "(float x)")
                                           c (str proto " { "
                                                  " char output[50];"
                                                  " snprintf(output, 50, \"%f\", x);"
                                                  " return strdup(output);"
                                                  "}")]
                                       {:proto proto :c c :deps ()})

              (:fn (:double) :string) (let [proto (str "API string " c-func-name "(double x)")
                                           c (str proto " { "
                                                  " char output[50];"
                                                  " snprintf(output, 50, \"%f\", x);"
                                                  " return strdup(output);"
                                                  "}")]
                                       {:proto proto :c c :deps ()})

              (:fn ((:ref :string)) :string) (instantiate-str-for-string c-func-name)

              (:fn ((:ref maybe-struct-type)) :string) (instantiate-str-for-struct c-func-name maybe-struct-type)
              
              x (error (str "Invalid (non-ref?) type for call to 'str': " x))))

    "delete" (do
               (match signature
                 (:fn ((:Array t)) :void) (instantiate-delete-for-array c-func-name t)
                 (:fn (:string) :void) (instantiate-delete-for-string c-func-name)
                 (:fn (maybe-struct-type) :void) (instantiate-delete-for-struct c-func-name maybe-struct-type)
                 x (error (str "Invalid type for call to 'delete': " x))))

    "copy" (do
             (match signature
               (:fn ((:ref :float)) :float) (instantiate-copy-for-primitive-type c-func-name :float) ;; These are no-ops
               (:fn ((:ref :int)) :int) (instantiate-copy-for-primitive-type c-func-name :int) ;; These are no-ops
               (:fn ((:ref (:Array t))) t) (instantiate-copy-for-array c-func-name t)
               (:fn ((:ref :string)) :string) (instantiate-copy-for-string c-func-name)
               ;;(:fn (:string) :string) (instantiate-copy-for-string c-func-name)
               (:fn ((:ref maybe-struct-type)) maybe-struct-type) (instantiate-copy-for-struct c-func-name maybe-struct-type)
               x (error (str "Invalid type for call to 'copy': " x))))
    
    "nth" (match signature
            (:fn ((:ref (:Array t)) :int) (:ref t))
            (let [proto (str "API " (type-build t) " " c-func-name "(Array *a, int index)")
                  c (str proto " { return ((" (type-build t) "*)(a->data))[index]; }")]
              {:proto proto :c c :deps ()})
            _ (error "Invalid type for call to 'nth'"))

    "count" (match signature
              (:fn ((:ref (:Array t))) :int)
              (let [proto (str "API int " c-func-name "(Array *a)")
                    c (str proto " { return a->count; }")]
                {:proto proto :c c :deps ()})
              _ (error "Invalid type for call to 'count'"))
    
    "array-of-size" (match signature
                      (:fn (:int) (:Array t))
                      (let [proto (str "API " (type-build '(:Array t)) " " c-func-name "(int count)")
                            c (str proto
                                   "{ Array *a = malloc(sizeof(Array));"
                                   " a->count = count;"
                                   " a->data = calloc(count, sizeof(" (type-build t) "));"
                                   " return a;"
                                   " }")]
                        {:proto proto :c c :deps ()})
                      x (error (str "Invalid type for call to 'array-of-size': " x)))

    ;; "reduce" (match signature
    ;;            (:fn ((:fn ("a" "b") "a") "a" (:Array "b")) "a")
    ;;            (let [proto (str "API " (type-build '(:Array t)) " " c-func-name "(f, a, bs)")
    ;;                  c (str proto
    ;;                         "{\n"
    ;;                         "  return a;\n"
    ;;                         "}\n")]
    ;;              {:proto proto :c c :deps ()})
    ;;            x (error (str "Invalid type for call to 'reduce': " x)))

    
    "array-set" (match signature
                  (:fn ((:Array t) :int t) (:Array t))
                  (let [proto (str "API " (type-build '(:Array t)) " " c-func-name "(Array *a, int index, " (type-build t) " value)")
                        c (str proto " { ((" (type-build t) "*)(a->data))[index] = value; return a; }")]
                    {:proto proto :c c :deps ()})
                  _ (error "Invalid type for call to 'array-set'"))


    x (error (str "Can't build generic primop for '" x "'"))))


(defn instantiate-str-for-string [c-func-name]
  (let [proto (str "API string " c-func-name "(string s)")
        c (str proto " {\n"
               ;;" printf(\"calling str on string '%s'\\n\", s);\n"
               " int len = strlen(s);\n"
               " int new_len = len + 3;\n"
               " char *new_s = malloc(sizeof(char) * new_len);\n"
               " memcpy(new_s + 1, s, len); "
               " new_s[0] = '\"';\n"
               " new_s[new_len - 2] = '\"';\n"
               " new_s[new_len - 1] = '\\0';\n"
               " return new_s;\n"
               "}\n")]
    {:proto proto :c c :deps ()}))

(defn ref-or-no-ref [t]
  (if (primitive-type? t)
    t
    (list :ref t)))

(defn instantiate-str-for-struct [c-func-name maybe-struct-type]
  (if (keyword? maybe-struct-type)
    (let [_ (when (or (= :string maybe-struct-type)
                      (primitive-type? maybe-struct-type))
              (error (str "Primitive type sent to 'str' instantiator for struct types, but it is not a struct type: " maybe-struct-type)))
          lookup (eval (symbol (name maybe-struct-type)))]
      (if (and (dict? lookup) (= true (get-maybe lookup :struct)))
        (let [t-name (name maybe-struct-type)
              proto (str "string " c-func-name "(" t-name " *x)")
              member-names (array-to-list (:member-names lookup))
              member-types (array-to-list (:member-types lookup))
              reffed-member-types (map (fn [mt] (ref-or-no-ref mt)) member-types)
              ;;_ (println (str "reffed-member-types: " reffed-member-types))
              ;;_ (build-constructor t-name member-names member-types) ;; build the constructor type to make it accessible to this function
              deps (map (fn [t] (c-ify-name (generic-name "str" (list :fn (list t) :string)))) reffed-member-types)
              ;;_ (println (str "deps: " deps))
              c (str proto " {\n"
                     "  char buffer[1024];\n"
                     "  int pos = 0;\n"
                     "  buffer[pos++] = '(';\n"
                     "  snprintf(buffer + pos, 1000, \"%s\", \"" t-name "\");"
                     "  pos += " (strlen t-name) ";"
                     "  buffer[pos++] = ' ';\n"
                     "  char *s;"
                     (join " " (map2 (fn [t n]
                                       (do
                                         ;;(println (str "t: " t))
                                         (bake-generic-primop-auto "str" (list :fn (list t) :string))
                                         (str "
  s = " (c-ify-name (generic-name "str" (list :fn (list t) :string))) "(x->" (c-ify-name n) "); 
  snprintf(buffer + pos, 1000, \"%s\", s);
  pos += strlen(s);
  buffer[pos++] = ' ';")))
                                     reffed-member-types
                                     member-names))
                     "  \n"
                     "  pos--;\n"
                     "  buffer[pos++] = ')';\n"
                     "  buffer[pos++] = '\\0';\n"
                     "  return strdup(buffer);\n"
                     ;;"return \"" t-name "\"; "
                     "}\n")]
          {:proto proto
           :c c
           :deps deps})
        (error (str "Invalid (non-struct) type for call to 'str': " maybe-struct-type "\n" lookup))))
    (error (str "Invalid type for call to 'str': " maybe-struct-type))))

(defn instantiate-str-for-array [c-func-name t]
  (let [proto (str "API string " c-func-name "(Array *a)")
        ;; Call str without ref for primitive types, otherwise use ref
        inner-arg-type (if (primitive-type? t) t (list :ref t))
        inner-signature (list :fn (list inner-arg-type) :string)
        inner-str-call (c-ify-name (generic-name (symbol "str") inner-signature))
        _ (bake-generic-primop-auto "str" inner-signature)
        ;;_ (println (str "inner-str-call: " inner-str-call))
        c (str proto
               "{\n"
               " printf(\"array %p count: %d\\n\", a, a->count); \n"
               " char buffer[1024];\n"
               " int pos = 0;\n"
               " int count = a->count;\n"
               " buffer[pos++] = '[';\n"
               " " (type-build t) " *casted_data = a->data;\n"
               " for(int i = 0; i < count; i++) {\n"
               ;;"   printf(\"%d \", casted_data[i]);\n"
               "   char *inner_str = " inner-str-call "(casted_data[i]);\n"
               "   snprintf(buffer + pos, 1024 - pos - 1,\"%s\", inner_str);\n"
               "   pos += strlen(inner_str);\n"
               "   if(i < count - 1) {\n"
               "     buffer[pos++] = ',';\n"
               "     buffer[pos++] = ' ';\n"
               "   }"
               " }"
               " buffer[pos++] = ']';\n"
               " buffer[pos++] = '\\0';\n"
               " return strdup(buffer);\n"
               "}")]
    {:proto proto :c c :deps (list inner-str-call)}))



(defn instantiate-copy-for-string [c-func-name]
  (let [;;_ (println (str "instantiate " c-func-name))
        proto (str "API string " c-func-name "(string s)")
        c (str proto " { return strdup(s); }")]
    {:proto proto :c c :deps ()}))

(defn instantiate-copy-for-primitive-type [c-func-name t]
  (let [proto (str "API " (type-build t) " " c-func-name "(" (type-build t)" x)")
        c (str proto " { return x; }")]
    {:proto proto :c c :deps ()}))

(defn instantiate-copy-for-struct [c-func-name maybe-struct-type]
  (if (keyword? maybe-struct-type)
    (let [_ (when (or (= :string maybe-struct-type)
                      (primitive-type? maybe-struct-type))
              (error (str "Primitive type sent to 'copy' instantiator for struct types, but it is not a struct type: " maybe-struct-type)))
          lookup (eval (symbol (name maybe-struct-type)))]
      (if (and (dict? lookup) (= true (get-maybe lookup :struct)))
        (let [t-name (name maybe-struct-type)
              proto (str t-name " *" c-func-name "(" t-name " *x)")
              ;;_ (println (str "proto for struct copying function: " proto))
              member-names (array-to-list (:member-names lookup))
              member-types (array-to-list (:member-types lookup))
              c (str proto " { \n"
                     "  " (type-build maybe-struct-type) " x_copy = calloc(1, sizeof(" t-name "));\n"
                     (join " " (map2 (fn [t n]
                                       (if (primitive-type? t)
                                         (str "  x_copy->" (c-ify-name n) " = x->" (c-ify-name n) ";\n")
                                         (let [inner-copy-sig (list :fn (list (list :ref t)) t)
                                               copy-function-c-name (c-ify-name (generic-name "copy" inner-copy-sig))]
                                           (do
                                             (bake-generic-primop-auto "copy" inner-copy-sig)
                                             (str "x_copy->" (c-ify-name n) " = " copy-function-c-name "(x->" (c-ify-name n) ");\n")))))                                           
                                     member-types
                                     member-names))
                     "  return x_copy;\n"
                     "}\n")]
          {:proto proto
           :c c
           :deps (map (fn [t] (c-ify-name (generic-name "copy" (list :fn (list (list :ref t)) t))))
                        (remove primitive-type? member-types))})
        (error (str "Invalid (non-struct) type for call to 'str': " maybe-struct-type "\n" lookup))))
    (error (str "Invalid type for call to 'str': " maybe-struct-type))))

(defn instantiate-copy-for-array [c-func-name array-type]
  (let [proto (str "API Array *" c-func-name "(Array *a)")
        ;; Call str without ref for primitive types, otherwise use ref
        t (second array-type)
        inner-arg-type (if (primitive-type? t) t (list :ref t))
        inner-signature (list :fn (list (list :ref t)) t)
        inner-copy-call (if (primitive-type? t)
                          ""
                          (c-ify-name (generic-name "copy" inner-signature)))
        ;;_ (println (str "inner-copy-call: " inner-copy-call))
        _ (when (not (primitive-type? t))
            (bake-generic-primop-auto "copy" inner-signature))
        c (str proto
               "{ \n"
               "  Array *a_copy = malloc(sizeof(Array));\n"
               "  a_copy->count = a->count;\n"
               "  a_copy->data = calloc(a->count, sizeof(" (type-build inner-arg-type) "));\n"
               "  int count = a_copy->count;\n"
               "  " (type-build t) " *casted_data = a->data;\n"
               "  " (type-build t) " *casted_data_copy = a_copy->data;\n"
               "  for(int i = 0; i < count; ++i) {\n"
               (if (primitive-type? t)
                 "    casted_data_copy[i] = casted_data[i];\n"
                 (str "    casted_data_copy[i] = " inner-copy-call "(casted_data[i]);\n"))
               "  }\n"
               "  return a_copy; \n"
               "}\n")]
    {:proto proto
     :c c
     :deps (if (primitive-type? t)
             '()
             (list inner-copy-call))}))







(defn instantiate-delete-for-string [c-func-name]
  (let [proto (str "API void " c-func-name "(string s)")
        c (str proto " { free(s); }")]
    {:proto proto :c c :deps ()}))

(defn instantiate-delete-for-struct [c-func-name maybe-struct-type]
  (if (keyword? maybe-struct-type)
    (let [_ (when (or (= :void maybe-struct-type)
                      (= :string maybe-struct-type)
                      (primitive-type? maybe-struct-type))
              (error (str "Primitive type sent to 'delete' instantiator for struct types, but it is not a struct type: " maybe-struct-type)))
          lookup (eval (symbol (name maybe-struct-type)))]
      (if (and (dict? lookup) (= true (get-maybe lookup :struct)))
        (let [t-name (name maybe-struct-type)
              proto (str "void " c-func-name "(" t-name " *x)")
              ;;_ (println (str "proto for struct delete function: " proto))
              member-names (array-to-list (:member-names lookup))
              member-types (array-to-list (:member-types lookup))
              c (str proto " {\n"
                     (join "" (map2 (fn [t n]
                                      (if (managed-type? t)
                                        (let [inner-delete-sig (list :fn (list t) :void)
                                              delete-function-c-name (str "delete__" (c-ify-name (generic-safe-name t)) "_void")]
                                          (do
                                            (bake-generic-primop-auto "delete" inner-delete-sig)
                                            (str "  " delete-function-c-name "(x->" (c-ify-name n) ");\n")))
                                        (str "  /* no need to delete " t " member '" n "' */\n")))
                                    member-types
                                    member-names))
                     "  free(x);\n"
                     "}\n")]
          {:proto proto
           :c c
           :deps (map (fn [t] (str "delete__" (c-ify-name (generic-safe-name t)) "_void")) (filter managed-type? member-types))})
        (error (str "Invalid (non-struct) type for call to 'str': " maybe-struct-type "\n" lookup))))
    (error (str "Invalid type for call to 'str': " maybe-struct-type))))

(defn instantiate-delete-for-array [c-func-name t]
  (let [proto (str "API void " c-func-name "(Array *a)")
        inner-signature (list :fn (list t) :void)
        inner-delete-call (c-ify-name (generic-name "delete" inner-signature))
        ;;_ (println (str "inner-delete-call: " inner-delete-call))
        _ (when (not (primitive-type? t))
            (bake-generic-primop-auto "delete" inner-signature))
        c (str proto
               "{ \n"
               (if (primitive-type? t)
                 "/* no inner pointers to delete */\n"
                 (str
                  "  int count = a->count;\n"
                  "  " (type-build t) " *casted_data = a->data;\n"
                  "  for(int i = 0; i < count; ++i) {\n"
                  (str "    " inner-delete-call "(casted_data[i]);\n")
                  "  }\n"
                  ))
               "  free(a->data);\n"
               "  free(a); \n"
               "}\n")]
    {:proto proto
     :c c
     :deps (if (primitive-type? t)
             '()
             (list inner-delete-call))}))

