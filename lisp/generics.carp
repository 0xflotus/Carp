
(defn generic-safe-name (t)
  (match t
         (:fn args ret) (str "FUNC" (join "" (map pretty-signature args)) "->" (pretty-signature ret))
         (:ref r) (str "REF" (pretty-signature r) "")
         x (if (keyword? t) (name t)
               (error (str "Invalid type signature: " t)))))


(defn generic-suffix (signature)
  (join "-" (map generic-safe-name (nth signature 1))))

(defn visit-generic-funcs [ast]
  (let [deps (copy (:func-deps ast))

        visit-generic-funcs-internal (fn [ast]
                                       (match (:node ast)
                                         :function (update-in ast '(:body) visit-generic-funcs-internal)
                                         :app (let [ast0 (update-in ast '(:head) visit-generic-funcs-internal) ;; todo: use a here
                                                    ast1 (update-in ast0 '(:tail) (fn (a) (map visit-generic-funcs-internal (:tail ast))))]
                                                ast1)
                                         :lookup (let [t (:type ast)]
                                                   (do
                                                     ;;(println (str (:value ast) " : " t))
                                                     (if (and (nil? (get-maybe ast :self-recursive)) (:global-lookup ast))
                                                       (let [lookup-sym (:value ast)
                                                             ;;_ (println (str "Will eval " ast))
                                                             global-lookup (eval lookup-sym)
                                                             lookup-t (type global-lookup)
                                                             ;;_ (println (str "lookup-t: " lookup-t))
                                                             ]
                                                         (if (and (lambda? global-lookup) (meta-get lookup-t :generic))
                                                           (let [generic-name (str lookup-sym "--" (generic-suffix t))]
                                                             (do
                                                               ;;(println (str "generic lookup of '" lookup-sym "', t: " t ", lookup-t: " lookup-t ", n: " generic-name))
                                                               (bake-generic-func-internal (new-builder) generic-name (code global-lookup) '() false t)
                                                               (reset! deps (cons (symbol generic-name) deps))
                                                               (let [ast0 (assoc-in ast '(:value) (symbol generic-name)) ;; make it call another function...
                                                                     ]
                                                                 ast0))) 
                                                             ast))
                                                       ast)))

                                         :if (let [ast0 (update-in ast '(:expr) visit-generic-funcs-internal)
                                                   ast1 (update-in ast0 '(:if-true) visit-generic-funcs-internal)
                                                   ast2 (update-in ast1 '(:if-false) visit-generic-funcs-internal)]
                                               ast2)

                                         :binop (let [ast0 (update-in ast '(:left) visit-generic-funcs-internal)
                                                      ast1 (update-in ast0 '(:right) visit-generic-funcs-internal)]
                                                  ast1)

                                         :reset (let [ast0 (update-in ast '(:expr) visit-generic-funcs-internal)]
                                                  ast0)

                                         :literal ast

                                         :ref ast

                                         :let ast

                                         :do (update-in ast '(:forms) (fn [forms] (map visit-generic-funcs-internal forms)))
                                         
                                         x (error (str "visit-generic can't handle node type " x))))]
    (assoc (visit-generic-funcs-internal ast) :func-deps deps)))
