
(defn type-of-value [val]
  (let [t (type val)]
    (if (or (= :ptr t) (= :ptr-to-global t))
      (meta-get val :type)
      (match t
        :array (if (= 0 (count val))
                 (error (str "Can't figure out type from empty array."))
                 (list :Array (type-of-value (nth val 0))))
        _ t))))

(defn type-of-global [global-variable-name]
  (let [s (symbol global-variable-name)
        t (type-of-value (eval s))]
    (do
      ;;(println (str "type of global " global-variable-name " is " t))
      t)))

(defn bake-global [variable-name deps]
  (let [t (type-of-global variable-name)
        evaled (eval (symbol variable-name))
        ;;_ (println (str "Global " variable-name " to bake has type " t " and value " evaled)) ;; <- BUG!!!
        c-variable-name (c-ify-name variable-name)
        init-value (if (contains? '(:int :float :double :string) t)
                     (prn evaled)
                     "NULL")
        ]
    (if (graph/node-exists? variable-name)
      (do
        (println (str "Warning: ignoring already baked global variable: '" variable-name "'"))
        :ignored)
      (do
        ;;(println (str "Adding global named " variable-name " of type " t))
        (let [prototype (str "extern " (type-build t) " " c-variable-name ";")
              c-code (str (type-build t) " " c-variable-name " = " init-value ";")
              init-closure-name (str variable-name "-init-closure")
              deps (list)]
          (do
            (compiler/bake-src variable-name prototype c-code t deps)
            (reset! deps (cons (symbol init-closure-name) deps))
            (when (= "NULL" init-value)
              (bake-init-closure init-closure-name variable-name evaled t))
            (when (= init-value "NULL") (eval (list 'reset! (symbol variable-name) evaled)))
            :baked))))))

(defn bake-init-closure [func-name global-name body return-type]
  (let [func-def (list 'defn (symbol func-name) [] (list 'reset! (symbol global-name) body))]
    (do
      ;;(println (str "Defining init closure for " global-name ": " func-def))
      (eval func-def)
      (eval (list 'meta-set! (symbol func-name) :signature (list 'quote (list :fn () return-type))))
      (compiler/bake-function-and-its-dependers func-name)
      (graph/update-node! func-name :is-init-closure true)
      )))

;; (defn bake-init-closure [func-name global-name body return-type]
;;   (let [func-code (list 'fn [] (list 'reset! (symbol global-name) (read (str body))))
;;         signature (list :fn () return-type)]
;;     (do
;;       (println (str "Defining init closure for " global-name ":\n" func-code "\n"))
      
;;       (eval (copy (list 'def (symbol func-name) (copy func-code))))
      
;;       ;;(eval (list 'def (symbol func-name) func-code))
;;       ;;(compiler/bake-function-and-its-dependers func-name)
      
;;       ;;(eval (list 'meta-set! (symbol func-name) :signature (list 'quote (list :fn () return-type))))
;;       ;;(compiler/bake-function-and-its-dependers func-name)
;;       ;;(graph/update-node! func-name :is-init-closure true)
;;       func-code )))
