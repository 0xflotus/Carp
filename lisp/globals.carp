
(defn type-of-value [val]
  (let [t (type val)]
    (if (or (= :ptr t) (= :ptr-to-global t))
      (meta-get val :type)
      (match t
        :array (if (= 0 (count val))
                 (error (str "Can't figure out type from empty array."))
                 (list :Array (type-of-value (nth val 0))))
        _ t))))

(defn type-of-global [global-variable-name]
  (let [s (symbol global-variable-name)]
    (do
      ;;(println (str "type of " global-variable-name " is " t))
      (type-of-value (eval s)))))

(defn bake-global [variable-name deps]
  (let [t (type-of-global variable-name)
        evaled (eval (symbol variable-name))        
        ;;_ (println (str variable-name " has type " t))
        c-variable-name (c-ify-name variable-name)
        init-value (if (contains? '(:int :float :double :string) t)
                     (prn evaled)
                     "NULL")
        ]
    (if (graph/node-exists? variable-name)
      (do
        ;;(println (str "Ignoring already baked global variable: " variable-name))
        nil)
      (do
        ;;(println (str "Adding global named " variable-name " of type " t))
        (let [prototype (str "extern " (type-build t) " " c-variable-name ";")
              c-code (str (type-build t) " " c-variable-name " = " init-value ";")
              init-closure-name (get-global-init-func-name)
              deps (list)]
          (do
            (bake-c-code variable-name t c-variable-name (str out-dir c-variable-name ".c") c-code prototype deps false)
            ;;(add-global! variable-name prototype)
            (reset! deps (cons (symbol init-closure-name) deps))
            (bake-init-closure init-closure-name variable-name evaled t)
            (when (= init-value "NULL") (eval (list 'reset! (symbol variable-name) evaled)))
            ))))))



(def global-init-counter -1)

(defn get-global-init-func-name []
  (do (reset! global-init-counter (inc global-init-counter))
      (str "global_init_" global-init-counter)))

(defn bake-init-closure [func-name global-name body return-type]
  (let [func-def (list 'defn (symbol func-name) [] (list 'reset! (symbol global-name) body))]
    (do
      ;;(println (str "defining init closure for " global-name ": " func-def))
      (eval func-def)
      (eval (list 'meta-set! (symbol func-name) :signature (list 'quote (list :fn () return-type))))
      (bake-internal func-name (eval (list 'code (symbol func-name))) () () false (new-builder))
      )))
