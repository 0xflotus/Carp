;; The dependency graph
;;
;; Nodes are functions, groups of mutually recursive functions, modules, structs, etc.
;; Each node can be compiled into its own dynamic library and depends on a set of other nodes.
;; Compiling a node should be very straight forward:
;;
;;  (bake-node "foo")
;;
;; The whole graph lives in a data structure called 'graph' which is a big dictionary.

(def graph {})
(def graph-src {})

^doc "kind - :function / :global (variable) / :struct / :module / function-type
      name - a string, also the key in the graph dictionary
      proto - what will go into the header file
      src - what will go into the C-file
      dylib-name - a string, the name used to link to the partical dylib where this node is compiled
      dylib-ptr - pointer to the dylib Obj
      depends-on - a list of names of nodes that this node depend on
     "
(defn graph/add-node! [kind name proto src dylib-name dylib-ptr depends-on]
  (do (dict-set! graph-src name src)
      (dict-set! graph name {:kind kind
                             :name name
                             :proto proto
                             :dylib-name dylib-name
                             :dylib-ptr dylib-ptr
                             :depends-on (map str depends-on)})))


(defn graph/dependers [name]
  (set
   (mapcat (fn [node]
             (let [deps (:depends-on node)]
               (if (contains? deps name)
                 (concat (list (:name node)) (graph/dependers (:name node)))
                 ())))
           (values graph))))

(defn graph/node-exists? [name]
  (not-nil? (get-maybe graph name)))

(def extra-header-deps ())

(defn graph/save-prototypes! ()
  (save (str out-dir "declarations.h")
        (str
         "#include <shared.h>\n"
         (join "\n" (map (fn [header] (str "#include " header)) extra-header-deps))
         "\n\n//Structs:\n"
         (join "\n" (map :proto (filter (fn [n] (= (:kind n) :struct)) (values graph))))
         "\n\n//Function types:\n"
         (join "\n" (map :proto (filter (fn [n] (= (:kind n) :function-type)) (values graph))))
         "\n\n//Globals:\n"
         (join "\n" (map :proto (filter (fn [n] (= (:kind n) :global)) (values graph))))
         "\n\n//Functions:\n"
         (join "\n" (map :proto (filter (fn [n] (= (:kind n) :function)) (values graph))))
         "\n")))

