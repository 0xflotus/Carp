(reset! echo-signature-after-bake true)

(when (not carp-dev)
  (do
    ;;(load-lisp (str carp-dir "lisp/string_array.carp"))
    ;;(load-lisp (str carp-dir "lisp/glfw_test.carp"))
    (load-lisp (str carp-dir "lisp/examples.carp"))
    nil
    ))

(def x '(1 2 3))

(defn id [x] x)

(defn id-test []
  (id 123))

(def iast (lambda-to-ast (code id-test)))

;; (def icon (gencon iast)) <-- KRASCH!
;; (def iasta (annotate-ast iast))

;;(meta-set! x :dangerous 10)

(defn whatever [a b]
  100)

(defn test-whatever-1 []
  (whatever 1 2))

(defn test-whatever-2 []
  (whatever "hej" "svejs"))

;; (bake test-whatever-1)


(defstruct Vec2 [x :float y :float])

(def v (Vec2 3.0 4.0))

(def x (#x v))
(def y (#y v))

;; pretend that the FauxVec2 type in shared.h is the same as Vec2 (they have the same memory layout):
(register-builtin "position" '() :Vec2)

(defn print-vec2 [m]
  (println (str (#x m) ", " (#y m))))

(defstruct Mix [a :int b :float c :int])

(def m (Mix 10 3.2 20))

(defn print-mix [m]
  (println (str "Mix: " (#a m) ", " (#b m) ", " (#c m))))

(defstruct Mix2 [mix-a :Mix mix-b :Mix])
(def m2 (Mix2 (Mix 1 2.0 3) (Mix 4 5.0 6)))

(defn test-mix2 []
  (do
    (print-mix (#mix-a m2))
    (print-mix (#mix-b m2))))




(defn letpoly []
  (let [x (id (string-copy "hej"))
        y (id 120)]
    (+ (strlen x) y)))



(defn get-a-float [xs]
  (* 2.0f (nth xs 0)))

(defn test-get-a-float []
  (do (bake get-a-float)))


(defn test-int-array []
  (+ 100 (nth (array-of-size 3) 0)))





(defn small-array []
  (let [a (array-of-size 3)
        b (array-set a 0 10)
        c (array-set b 1 20)
        d (array-set c 2 30)]
    d))

;; (def small-ast (lambda-to-ast (code small-array)))
;; (def small-con (gencon small-ast))
;; (def small-sol (solve-constraints small-con))
;; (def small-asta (annotate-ast small-ast))



(defn small-array-2 []
  ;;(array-set
   (array-set
    (array-set
     (array-of-size 3)
     0 10)
    1 20)
   ;;2 30)
  )

;; (def small-2-ast (lambda-to-ast (code small-array-2)))
;; (def small-2-con (gencon small-2-ast))
;; (def small-2-sol (solve-constraints small-2-con))
;; (def small-2-asta (annotate-ast small-2-ast))



(defn print-small-array []
  (let [a (small-array)]
    (do (print "[")
        (print (ref (itos (nth (ref a) 0))))
        (print ", ")
        (print (ref (itos (nth (ref a) 1))))
        (print ", ")
        (print (ref (itos (nth (ref a) 2))))
        (println "]"))))

;; (defn print-small-array []
;;   (let [a (small-array)]
;;     (print (ref (itos (nth (ref a) 0))))
;;         ))

;; (bake small-array)
;; (def ps-ast (lambda-to-ast (code print-small-array)))
;; (def ps-con (gencon ps-ast))
;; (def ps-sol (solve-constraints ps-con))
;;(def ps-asta (annotate-ast ps-ast))





(defn array-literal []
  [10 20 30])

(def last (lambda-to-ast (code array-literal)))
(def lcon (gencon last))
(def tlast (infer-types last nil))
(def lasta (annotate-ast last))

(defn test-array-literal []
  nil)
