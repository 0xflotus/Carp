(reset! echo-signature-after-bake true)
(reset! log-unloading-of-dylibs true)

(when (not carp-dev)
  (do
    ;;(load-lisp (str carp-dir "lisp/glfw_test.carp"))
    (load-lisp (str carp-dir "lisp/examples.carp"))
    nil
    ))

;;(load-gl)


;; (defn no-nesting []
;;   [666])

;;(def ast1 (lambda-to-ast (code no-nesting)))
;;(def con1 (gencon1))

;; (defn nesting1 []
;;   [(string-copy "hej")])
;; (def ast1 (annotate-ast (lambda-to-ast (code nesting1))))

;; (defn nesting2 []
;;   [3.0 2.0 1.0])
;; (def ast2 (annotate-ast (lambda-to-ast (code nesting2))))

;; (defn nesting3 []
;;   [[1000 2000 3000]])
;; (def ast3 (annotate-ast (lambda-to-ast (code nesting3))))


(defn nesting []
  [[(string-copy "hej")]])

(def ast (lambda-to-ast (code nesting)))
(def con (gencon ast))

;;(def asta (annotate-ast ast2))


(defn copy-1 []
  (copy "CARP"))

(defn test-copy-1 []
  (do
    (bake copy-1)
    (assert-eq "CARP" (copy-1))))

(test-copy-1)



(defstruct CopyMe [copyMeMember :int])

(defn copy-2 []
  (copy (ref (CopyMe 666))))

(defn test-copy-2 []
  (do
    (bake copy-2)
    (assert-eq 666 (get-copyMeMember (copy-2)))))

(test-copy-2)




(defstruct AnotherCopy [aNameToCopy :string anotherNameToCopy :string])

(defn copy-3 [n1 n2]
  (copy (ref (AnotherCopy n1 n2))))

(defn test-copy-3 []
  (do
    (bake copy-3)
    (assert-eq "(AnotherCopy \"AHA\" \"BUHU\")" (str (copy-3 "AHA" "BUHU")))))

(test-copy-3)
