module Deftype (moduleForDeftype) where

import qualified Data.Map as Map
import Data.Maybe
import Debug.Trace

import Obj
import Types
import Util
import Template
import Infer

data AllocationMode = StackAlloc | HeapAlloc

-- | This function creates a "Type Module" with the same name as the type being defined.
--   A type module provides a namespace for all the functions that area automatically
--   generated by a deftype.
moduleForDeftype :: Env -> Env -> [String] -> String -> [XObj] -> Maybe Info -> Maybe (String, XObj, [XObj])
moduleForDeftype typeEnv env pathStrings typeName rest i =
  let typeModuleName = typeName                   
      emptyTypeModuleEnv = Env (Map.fromList []) (Just env) (Just typeModuleName) [] ExternalEnv
      -- The variable 'insidePath' is the path used for all member functions inside the 'typeModule'.
      -- For example (module Vec2 [x Float]) creates bindings like Vec2.create, Vec2.x, etc.
      insidePath = pathStrings ++ [typeModuleName]      
  in do _ <- validateMembers rest
        okInit <- templateForInit insidePath typeName rest
        okNew <- templateForNew insidePath typeName rest
        (okDelete, deleteDeps) <- templateForDelete typeEnv env insidePath typeName rest
        (okCopy, copyDeps) <- templateForCopy typeEnv env insidePath typeName rest
        (okMembers, membersDeps) <- templatesForMembers typeEnv env insidePath typeName rest
        let funcs = okInit : okNew : okDelete : okCopy : okMembers
            moduleEnvWithBindings = addListOfBindings emptyTypeModuleEnv funcs
            typeModuleXObj = XObj (Mod moduleEnvWithBindings) i (Just ModuleTy)
            deps = deleteDeps ++ membersDeps ++ copyDeps
        return (typeModuleName, typeModuleXObj, deps)

-- | What a mess this function is...
validateMembers :: [XObj] -> Maybe ()
validateMembers rest = if all (== True) (map validateOneCase rest)
                       then Just ()
                       else Nothing

validateOneCase :: XObj -> Bool
validateOneCase (XObj (Arr arr) _ _) = length arr `mod` 2 == 0 &&
                                       all okMemberType (map snd (pairwise arr))
validateOneCase XObj {} = False

okMemberType :: XObj -> Bool
okMemberType xobj = case xobjToTy xobj of
                      Just _ -> True
                      Nothing -> False

initArgListTypes :: [XObj] -> [Ty]
initArgListTypes xobjs = map (\(_, x) -> fromJust (xobjToTy x)) (pairwise xobjs)

templateForInit :: [String] -> String -> [XObj] -> Maybe (String, Binder)
templateForInit insidePath typeName [XObj (Arr membersXObjs) _ _] =
  Just $ instanceBinder (SymPath insidePath "init")
                        (FuncTy (initArgListTypes membersXObjs) (StructTy typeName []))
                        (templateInit StackAlloc typeName (memberXObjsToPairs membersXObjs))
templateForInit _ _ _ = Nothing

templateForNew :: [String] -> String -> [XObj] -> Maybe (String, Binder)
templateForNew insidePath typeName [XObj (Arr membersXObjs) _ _] =
  Just $ instanceBinder (SymPath insidePath "new")
                        (FuncTy (initArgListTypes membersXObjs) (PointerTy (StructTy typeName [])))
                        (templateInit HeapAlloc typeName (memberXObjsToPairs membersXObjs))
templateForNew _ _ _ = Nothing

templateForDelete :: Env -> Env -> [String] -> String -> [XObj] -> Maybe ((String, Binder), [XObj])
templateForDelete typeEnv env insidePath typeName [XObj (Arr membersXObjs) _ _] =
  Just $ (instanceBinderWithDeps (SymPath insidePath "delete")
                                 (FuncTy [(StructTy typeName [])] UnitTy)
                                 (templateDelete typeEnv env (memberXObjsToPairs membersXObjs)))
templateForDelete _ _ _ _ _ = Nothing

templateForCopy :: Env -> Env -> [String] -> String -> [XObj] -> Maybe ((String, Binder), [XObj])
templateForCopy typeEnv env insidePath typeName [XObj (Arr membersXObjs) _ _] =
  Just $ (instanceBinderWithDeps (SymPath insidePath "copy")
                                 (FuncTy [(RefTy (StructTy typeName []))] (StructTy typeName []))
                                 (templateCopy typeEnv env (memberXObjsToPairs membersXObjs)))
templateForCopy _ _ _ _ _ = Nothing

memberXObjsToPairs :: [XObj] -> [(String, Ty)]
memberXObjsToPairs xobjs = map (\(n, t) -> (getName n, fromJust (xobjToTy t))) (pairwise xobjs)

templatesForMembers :: Env -> Env -> [String] -> String -> [XObj] -> Maybe ([(String, Binder)], [XObj])
templatesForMembers typeEnv env insidePath typeName [XObj (Arr membersXobjs) _ _] =
  let bindersAndDeps = concatMap (templatesForSingleMember typeEnv env insidePath typeName) (pairwise membersXobjs)
  in  Just (map fst bindersAndDeps, concatMap snd bindersAndDeps)
templatesForMembers _ _ _ _ _ = error "Can't create member functions for type with more than one case."

templatesForSingleMember :: Env -> Env -> [String] -> String -> (XObj, XObj) -> [((String, Binder), [XObj])]
templatesForSingleMember typeEnv env insidePath typeName (nameXObj, typeXObj) =
  let Just t = xobjToTy typeXObj
      p = StructTy typeName []
      memberName = getName nameXObj
      fixedMemberTy = if isManaged t then (RefTy t) else t
  in [instanceBinderWithDeps (SymPath insidePath memberName) (FuncTy [(RefTy p)] fixedMemberTy) (templateGetter memberName fixedMemberTy)
     ,instanceBinderWithDeps (SymPath insidePath ("set-" ++ memberName)) (FuncTy [p, t] p) (templateSetter typeEnv env memberName t)
     ,instanceBinderWithDeps (SymPath insidePath ("update-" ++ memberName))
                                                            (FuncTy [p, (FuncTy [t] t)] p)
                                                            (templateUpdater memberName)]

templateInit :: AllocationMode -> String -> [(String, Ty)] -> Template
templateInit allocationMode typeName members =
  Template
    (FuncTy [] (VarTy "p"))
    (const (toTemplate $ "$p $NAME(" ++ joinWithComma (map memberArg members) ++ ")"))
    (const (toTemplate $ unlines [ "$DECL {"
                                 , case allocationMode of
                                     StackAlloc -> "    $p instance;"
                                     HeapAlloc ->  "    $p instance = malloc(sizeof(" ++ typeName ++ "));"
                                 , joinWith "\n" (map (memberAssignment allocationMode) members) 
                                 , "    return instance;"
                                 , "}"]))
    (const [])

memberArg :: (String, Ty) -> String
memberArg (memberName, memberTy) = tyToC memberTy ++ " " ++ memberName

memberAssignment :: AllocationMode -> (String, Ty) -> String
memberAssignment allocationMode (memberName, _) = "    instance" ++ sep ++ memberName ++ " = " ++ memberName ++ ";"
  where sep = case allocationMode of
                StackAlloc -> "."
                HeapAlloc -> "->"
  
templateGetter :: String -> Ty -> Template
templateGetter member fixedMemberTy =
  let maybeAmpersand = case fixedMemberTy of
                         RefTy _ -> "&"
                         _ -> ""
  in 
  Template
    (FuncTy [RefTy (VarTy "p")] (VarTy "t"))
    (const (toTemplate "$t $NAME($(Ref p) p)"))
    (const (toTemplate ("$DECL { return " ++ maybeAmpersand ++ "(p->" ++ member ++ "); }\n")))
    (const [])

templateSetter :: Env -> Env -> String -> Ty -> Template
templateSetter typeEnv env memberName memberTy =
  let callToDelete = memberDeletion env (memberName, memberTy)
  in
  Template
    (FuncTy [VarTy "p", VarTy "t"] (VarTy "p"))
    (const (toTemplate "$p $NAME($p p, $t newValue)"))
    (const (toTemplate (unlines ["$DECL {"
                                ,callToDelete
                                ,"    p." ++ memberName ++ " = newValue;"
                                ,"    return p;"
                                ,"}\n"])))
    (\_ -> (memberDeletionDeps typeEnv env (memberName, memberTy)))

templateUpdater :: String -> Template
templateUpdater member =
  Template
    (FuncTy [VarTy "p", (FuncTy [VarTy "t"] (VarTy "t"))] (VarTy "p"))
    (const (toTemplate "$p $NAME($p p, $(Fn [t] t) updater)"))
    (const (toTemplate (unlines ["$DECL {"
                                ,"    p." ++ member ++ " = updater(p." ++ member ++ ");"
                                ,"    return p;"
                                ,"}\n"])))
    (\(FuncTy [_, t] _) -> [defineFunctionTypeAlias t])

templateDelete :: Env -> Env -> [(String, Ty)] -> Template
templateDelete typeEnv env members =
  Template
   (FuncTy [(VarTy "p")] UnitTy)
   (const (toTemplate $ "void $NAME($p p)"))
   (const (toTemplate $ unlines [ "$DECL {"
                                , (joinWith "\n" (map (memberDeletion env) members)) 
                                , "}"]))
   (\_ -> concatMap (memberDeletionDeps typeEnv env) members)

-- TODO: Should return an Either since this can fail.
memberDeletion :: Env -> (String, Ty) -> String
memberDeletion env (memberName, t)
  | isManaged t =
    case filter ((\(Just t') -> (areUnifiable (FuncTy [t] UnitTy) t')) . ty . binderXObj . snd) (multiLookupALL "delete" env) of
      [] -> "    /* Can't find any delete-function for member '" ++ memberName ++ "' */"
      [(_, Binder single)] ->
        let Just t' = ty single
            (SymPath pathStrings name) = getPath single
            suffix = polymorphicSuffix t' (FuncTy [t] UnitTy)
            concretizedPath = SymPath pathStrings (name ++ suffix)
        in  "    " ++ pathToC concretizedPath ++ "(p." ++ memberName ++ ");"
      _ -> "    /* Can't find a single delete-function for member '" ++ memberName ++ "' */"
  | otherwise   = "    /* Ignore non-managed member '" ++ memberName ++ "' */"

-- TODO: Should return an Either since this can fail.
memberDeletionDeps :: Env -> Env -> (String, Ty) -> [XObj]
memberDeletionDeps typeEnv env (memberName, t)
  | isManaged t =
    case filter ((\(Just t') -> (areUnifiable (FuncTy [t] UnitTy) t')) . ty . binderXObj . snd) (multiLookupALL "delete" env) of
      [] -> (trace $ "No delete function found for member '" ++ memberName ++ "'") []
      [(_, Binder (XObj (Lst ((XObj (Instantiate _) _ _) : _)) _ _))] ->
        []
      [(_, Binder single)] ->
        case concretizeDefinition False typeEnv env single (FuncTy [t] (UnitTy)) of
          Left err -> error (show err)
          Right (ok, deps) -> (ok : deps)
      _ -> (trace $ "Too many delete functions found for member '" ++ memberName ++ "'") []
  | otherwise = []





---------------------------------------------------------------------
-- Copy members, replace with "nameOfPolymorphicFunction" in Infer.hs

templateCopy :: Env -> Env -> [(String, Ty)] -> Template
templateCopy typeEnv env members =
  Template
   (FuncTy [(RefTy (VarTy "p"))] (VarTy "p"))
   (const (toTemplate $ "$p $NAME($p* pRef)"))
   (const (toTemplate $ unlines [ "$DECL {"
                                , "    $p copy = *pRef;"
                                , (joinWith "\n" (map (memberCopy env) members))
                                , "    return copy;"
                                , "}"]))
   (\_ -> concatMap (memberCopyDeps typeEnv env) members)

memberCopy :: Env -> (String, Ty) -> String
memberCopy env (memberName, t)
  | isManaged t =
    case filter ((\(Just t') -> (areUnifiable (FuncTy [(RefTy t)] t) t')) . ty . binderXObj . snd) (multiLookupALL "copy" env) of
      [] -> "    /* Can't find any copy-function for member '" ++ memberName ++ "' */"
      [(_, Binder single)] ->
        let Just t' = ty single
            (SymPath pathStrings name) = getPath single
            suffix = polymorphicSuffix t' (FuncTy [t] UnitTy)
            concretizedPath = SymPath pathStrings (name ++ suffix)
        in  "    copy." ++ memberName ++ " = " ++ pathToC concretizedPath ++ "(&(pRef->" ++ memberName ++ "));"
      _ -> "    /* Can't find a single copy-function for member '" ++ memberName ++ "' */"
  | otherwise   = "    /* Ignore non-managed member '" ++ memberName ++ "' */"

memberCopyDeps :: Env -> Env -> (String, Ty) -> [XObj]
memberCopyDeps typeEnv env (memberName, t)
  | isManaged t =
    case filter ((\(Just t') -> (areUnifiable (FuncTy [(RefTy t)] t) t')) . ty . binderXObj . snd) (multiLookupALL "copy" env) of
      [] -> (trace $ "No copy function found for member '" ++ memberName ++ "'") []
      [(_, Binder (XObj (Lst ((XObj (Instantiate _) _ _) : _)) _ _))] ->
        []
      [(_, Binder single)] ->
        case concretizeDefinition False typeEnv env single (FuncTy [t] (UnitTy)) of
          Left err -> error (show err)
          Right (ok, deps) -> (ok : deps)
      _ -> (trace $ "Too many copy functions found for member '" ++ memberName ++ "'") []
  | otherwise = []
