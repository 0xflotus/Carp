module Deftype (moduleForDeftype) where

import qualified Data.Map as Map
import Data.Maybe
import Debug.Trace

import Obj
import Types
import Util
import Template
import Infer
import Concretize

data AllocationMode = StackAlloc | HeapAlloc

-- | This function creates a "Type Module" with the same name as the type being defined.
--   A type module provides a namespace for all the functions that area automatically
--   generated by a deftype.
moduleForDeftype :: Env -> Env -> [String] -> String -> [XObj] -> Maybe Info -> Either String (String, XObj, [XObj])
moduleForDeftype typeEnv env pathStrings typeName rest i =
  let typeModuleName = typeName                   
      emptyTypeModuleEnv = Env (Map.fromList []) (Just env) (Just typeModuleName) [] ExternalEnv
      -- The variable 'insidePath' is the path used for all member functions inside the 'typeModule'.
      -- For example (module Vec2 [x Float]) creates bindings like Vec2.create, Vec2.x, etc.
      insidePath = pathStrings ++ [typeModuleName]      
  in case validateMembers typeEnv rest of
       Left err ->
         Left err
       Right _ -> 
         case
           do okInit <- templateForInit insidePath typeName rest
              okNew <- templateForNew insidePath typeName rest
              (okDelete, deleteDeps) <- templateForDelete typeEnv env insidePath typeName rest
              (okCopy, copyDeps) <- templateForCopy typeEnv env insidePath typeName rest
              (okMembers, membersDeps) <- templatesForMembers typeEnv env insidePath typeName rest
              let funcs = okInit : okNew : okDelete : okCopy : okMembers
                  moduleEnvWithBindings = addListOfBindings emptyTypeModuleEnv funcs
                  typeModuleXObj = XObj (Mod moduleEnvWithBindings) i (Just ModuleTy)
                  deps = deleteDeps ++ membersDeps ++ copyDeps
              return (typeModuleName, typeModuleXObj, deps)
         of
           Just x -> Right x
           Nothing -> Left "Something's wrong with the templates..." -- TODO: Better messages here, should come from the template functions!           

-- | Make sure that the member declarations in a type definition
-- | Follow the pattern [<name> <type>, <name> <type>, ...]
-- | TODO: What a mess this function is, clean it up!
validateMembers :: Env -> [XObj] -> Either String ()
validateMembers typeEnv rest =
  mapM_ validateOneCase rest
  where
    validateOneCase :: XObj -> Either String ()
    validateOneCase (XObj (Arr arr) _ _) =
      if length arr `mod` 2 == 0
      then do mapM_ okXObjForType (map snd (pairwise arr))
      else Left "Uneven nr of members / types."
    validateOneCase XObj {} =
      Left "Type members must be defined using array syntax: [member1 type1 member2 type2 ...]"

    okXObjForType :: XObj -> Either String ()
    okXObjForType xobj =
      case xobjToTy xobj of
        Just t -> okMemberType t
        Nothing -> Left ("Can't interpret this as a type: " ++ pretty xobj)

    okMemberType :: Ty -> Either String ()
    okMemberType t = case t of
                       IntTy    -> return ()
                       FloatTy  -> return ()
                       DoubleTy -> return ()
                       BoolTy   -> return ()
                       StringTy -> return ()
                       CharTy   -> return ()
                       PointerTy inner -> do _ <- okMemberType inner
                                             return ()
                       StructTy "Array" [inner] -> do _ <- okMemberType inner
                                                      return ()
                       StructTy name tyVars ->
                         case lookupInEnv (SymPath [] name) typeEnv of
                           Just _ -> return ()
                           Nothing -> Left ("Can't find '" ++ name ++ "' among registered types.")
                       _ -> Left ("Invalid member type: " ++ show t)

-- | Helper function to create the binder for the 'init' template.
templateForInit :: [String] -> String -> [XObj] -> Maybe (String, Binder)
templateForInit insidePath typeName [XObj (Arr membersXObjs) _ _] =
  Just $ instanceBinder (SymPath insidePath "init")
                        (FuncTy (initArgListTypes membersXObjs) (StructTy typeName []))
                        (templateInit StackAlloc typeName (memberXObjsToPairs membersXObjs))
templateForInit _ _ _ = Nothing

-- | Helper function to create the binder for the 'new' template.
templateForNew :: [String] -> String -> [XObj] -> Maybe (String, Binder)
templateForNew insidePath typeName [XObj (Arr membersXObjs) _ _] =
  Just $ instanceBinder (SymPath insidePath "new")
                        (FuncTy (initArgListTypes membersXObjs) (PointerTy (StructTy typeName [])))
                        (templateInit HeapAlloc typeName (memberXObjsToPairs membersXObjs))
templateForNew _ _ _ = Nothing

-- | Generate a list of types from a deftype declaration.
initArgListTypes :: [XObj] -> [Ty]
initArgListTypes xobjs = map (\(_, x) -> fromJust (xobjToTy x)) (pairwise xobjs)

-- | Helper function to create the binder for the 'delete' template.
templateForDelete :: Env -> Env -> [String] -> String -> [XObj] -> Maybe ((String, Binder), [XObj])
templateForDelete typeEnv env insidePath typeName [XObj (Arr membersXObjs) _ _] =
  Just $ (instanceBinderWithDeps (SymPath insidePath "delete")
                                 (FuncTy [(StructTy typeName [])] UnitTy)
                                 (templateDelete typeEnv env (memberXObjsToPairs membersXObjs)))
templateForDelete _ _ _ _ _ = Nothing

-- | Helper function to create the binder for the 'copy' template.
templateForCopy :: Env -> Env -> [String] -> String -> [XObj] -> Maybe ((String, Binder), [XObj])
templateForCopy typeEnv env insidePath typeName [XObj (Arr membersXObjs) _ _] =
  Just $ (instanceBinderWithDeps (SymPath insidePath "copy")
                                 (FuncTy [(RefTy (StructTy typeName []))] (StructTy typeName []))
                                 (templateCopy typeEnv env (memberXObjsToPairs membersXObjs)))
templateForCopy _ _ _ _ _ = Nothing

-- | Get a list of pairs from a deftype declaration.
memberXObjsToPairs :: [XObj] -> [(String, Ty)]
memberXObjsToPairs xobjs = map (\(n, t) -> (getName n, fromJust (xobjToTy t))) (pairwise xobjs)

-- | Generate all the templates for ALL the member variables in a deftype declaration.
templatesForMembers :: Env -> Env -> [String] -> String -> [XObj] -> Maybe ([(String, Binder)], [XObj])
templatesForMembers typeEnv env insidePath typeName [XObj (Arr membersXobjs) _ _] =
  let bindersAndDeps = concatMap (templatesForSingleMember typeEnv env insidePath typeName) (pairwise membersXobjs)
  in  Just (map fst bindersAndDeps, concatMap snd bindersAndDeps)
templatesForMembers _ _ _ _ _ = error "Can't create member functions for type with more than one case (yet)."

-- | Generate the templates for a single member in a deftype declaration.
templatesForSingleMember :: Env -> Env -> [String] -> String -> (XObj, XObj) -> [((String, Binder), [XObj])]
templatesForSingleMember typeEnv env insidePath typeName (nameXObj, typeXObj) =
  let Just t = xobjToTy typeXObj
      p = StructTy typeName []
      memberName = getName nameXObj
      fixedMemberTy = if isManaged typeEnv t then (RefTy t) else t
  in [instanceBinderWithDeps (SymPath insidePath memberName) (FuncTy [(RefTy p)] fixedMemberTy) (templateGetter memberName fixedMemberTy)
     ,instanceBinderWithDeps (SymPath insidePath ("set-" ++ memberName)) (FuncTy [p, t] p) (templateSetter typeEnv env memberName t)
     ,instanceBinderWithDeps (SymPath insidePath ("update-" ++ memberName))
                                                            (FuncTy [p, (FuncTy [t] t)] p)
                                                            (templateUpdater memberName)]

-- | The template for the 'init' and 'new' functions for a deftype.
templateInit :: AllocationMode -> String -> [(String, Ty)] -> Template
templateInit allocationMode typeName members =
  Template
    (FuncTy [] (VarTy "p"))
    (const (toTemplate $ "$p $NAME(" ++ joinWithComma (map memberArg members) ++ ")"))
    (const (toTemplate $ unlines [ "$DECL {"
                                 , case allocationMode of
                                     StackAlloc -> "    $p instance;"
                                     HeapAlloc ->  "    $p instance = CARP_MALLOC(sizeof(" ++ typeName ++ "));"
                                 , joinWith "\n" (map (memberAssignment allocationMode) members) 
                                 , "    return instance;"
                                 , "}"]))
    (const [])

-- | Creates the C code for an arg to the init function.
-- | i.e. "(deftype A [x Int])" will generate "int x" which
-- | will be used in the init function like this: "A_init(int x)"
memberArg :: (String, Ty) -> String
memberArg (memberName, memberTy) = tyToC memberTy ++ " " ++ memberName

-- | Generate C code for assigning to a member variable.
-- | Needs to know if the instance is a pointer or stack variable.
memberAssignment :: AllocationMode -> (String, Ty) -> String
memberAssignment allocationMode (memberName, _) = "    instance" ++ sep ++ memberName ++ " = " ++ memberName ++ ";"
  where sep = case allocationMode of
                StackAlloc -> "."
                HeapAlloc -> "->"

-- | The template for getters of a deftype.
templateGetter :: String -> Ty -> Template
templateGetter member fixedMemberTy =
  let maybeAmpersand = case fixedMemberTy of
                         RefTy _ -> "&"
                         _ -> ""
  in 
  Template
    (FuncTy [RefTy (VarTy "p")] (VarTy "t"))
    (const (toTemplate "$t $NAME($(Ref p) p)"))
    (const (toTemplate ("$DECL { return " ++ maybeAmpersand ++ "(p->" ++ member ++ "); }\n")))
    (const [])

-- | The template for setters of a deftype.
templateSetter :: Env -> Env -> String -> Ty -> Template
templateSetter typeEnv env memberName memberTy =
  let callToDelete = memberDeletion env typeEnv (memberName, memberTy)
  in
  Template
    (FuncTy [VarTy "p", VarTy "t"] (VarTy "p"))
    (const (toTemplate "$p $NAME($p p, $t newValue)"))
    (const (toTemplate (unlines ["$DECL {"
                                ,callToDelete
                                ,"    p." ++ memberName ++ " = newValue;"
                                ,"    return p;"
                                ,"}\n"])))
    (\_ -> if isManaged typeEnv memberTy
           then (depsOfPolymorphicFunction typeEnv env "delete" (typesDeleterFunctionType memberTy))
           else [])

-- | The template for updater functions of a deftype
-- | (allows changing a variable by passing an transformation function).
templateUpdater :: String -> Template
templateUpdater member =
  Template
    (FuncTy [VarTy "p", (FuncTy [VarTy "t"] (VarTy "t"))] (VarTy "p"))
    (const (toTemplate "$p $NAME($p p, $(Fn [t] t) updater)"))
    (const (toTemplate (unlines ["$DECL {"
                                ,"    p." ++ member ++ " = updater(p." ++ member ++ ");"
                                ,"    return p;"
                                ,"}\n"])))
    (\(FuncTy [_, t] _) -> [defineFunctionTypeAlias t])

-- | The template for the 'delete' function of a deftype.
templateDelete :: Env -> Env -> [(String, Ty)] -> Template
templateDelete typeEnv env members =
  Template
   (FuncTy [(VarTy "p")] UnitTy)
   (const (toTemplate $ "void $NAME($p p)"))
   (const (toTemplate $ unlines [ "$DECL {"
                                , (joinWith "\n" (map (memberDeletion env typeEnv) members)) 
                                , "}"]))
   (\_ -> concatMap (depsOfPolymorphicFunction typeEnv env "delete" . typesDeleterFunctionType)
                    (filter (isManaged typeEnv) (map snd members)))

-- | Generate the C code for deleting a single member of the deftype.
-- | TODO: Should return an Either since this can fail!
memberDeletion :: Env -> Env -> (String, Ty) -> String
memberDeletion env typeEnv (memberName, memberType)
  | isManaged typeEnv memberType =
    case allFunctionsWithNameAndSignature  env "copy" (typesDeleterFunctionType memberType) of
      [] -> "    /* Can't find any delete-function for member '" ++ memberName ++ "' */"
      [(_, Binder single)] ->
        let Just t' = ty single
            (SymPath pathStrings name) = getPath single
            suffix = polymorphicSuffix t' (typesDeleterFunctionType memberType)
            concretizedPath = SymPath pathStrings (name ++ suffix)
        in  "    " ++ pathToC concretizedPath ++ "(p." ++ memberName ++ ");"
      _ -> "    /* Can't find a single delete-function for member '" ++ memberName ++ "' */"
  | otherwise = "    /* Ignore non-managed member '" ++ memberName ++ "' */"

-- | The template for the 'copy' function of a deftype.
templateCopy :: Env -> Env -> [(String, Ty)] -> Template
templateCopy typeEnv env members =
  Template
   (FuncTy [(RefTy (VarTy "p"))] (VarTy "p"))
   (const (toTemplate $ "$p $NAME($p* pRef)"))
   (const (toTemplate $ unlines [ "$DECL {"
                                , "    $p copy = *pRef;"
                                , (joinWith "\n" (map (memberCopy env typeEnv) members))
                                , "    return copy;"
                                , "}"]))
   (\_ -> concatMap (depsOfPolymorphicFunction typeEnv env "copy" . typesCopyFunctionType)
                    (filter (isManaged typeEnv) (map snd members)))

-- | TODO: Should return an Either since this can fail! Also, share code with memberDeletion
memberCopy :: Env -> Env -> (String, Ty) -> String
memberCopy env typeEnv (memberName, memberType)
  | isManaged typeEnv memberType =
    case allFunctionsWithNameAndSignature  env "copy" (typesCopyFunctionType memberType) of
      [] -> "    /* Can't find any copy-function for member '" ++ memberName ++ "' */"
      [(_, Binder single)] ->
        let Just t' = ty single
            (SymPath pathStrings name) = getPath single
            suffix = polymorphicSuffix t' (typesCopyFunctionType memberType)
            concretizedPath = SymPath pathStrings (name ++ suffix)
        in  "    copy." ++ memberName ++ " = " ++ pathToC concretizedPath ++ "(&(pRef->" ++ memberName ++ "));"
      _ -> "    /* Can't find a single copy-function for member '" ++ memberName ++ "' */"
  | otherwise   = "    /* Ignore non-managed member '" ++ memberName ++ "' */"

