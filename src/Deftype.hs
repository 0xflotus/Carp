module Deftype (moduleForDeftype) where

import qualified Data.Map as Map
import Data.Maybe
import Debug.Trace

import Obj
import Types
import Util
import Template
import Infer

data AllocationMode = StackAlloc | HeapAlloc

-- | This function creates a "Type Module" with the same name as the type being defined.
--   A type module provides a namespace for all the functions that area automatically
--   generated by a deftype.
moduleForDeftype :: Env -> Env -> [String] -> String -> [XObj] -> Maybe Info -> Maybe (String, XObj, [XObj])
moduleForDeftype typeEnv env pathStrings typeName rest i =
  let typeModuleName = typeName                   
      emptyTypeModuleEnv = Env (Map.fromList []) (Just env) (Just typeModuleName) [] ExternalEnv
      -- The variable 'insidePath' is the path used for all member functions inside the 'typeModule'.
      -- For example (module Vec2 [x Float]) creates bindings like Vec2.create, Vec2.x, etc.
      insidePath = pathStrings ++ [typeModuleName]      
  in do _ <- validateMembers rest
        okInit <- templateForInit insidePath typeName rest
        okNew <- templateForNew insidePath typeName rest
        (okDelete, deleteDeps) <- templateForDelete typeEnv env insidePath typeName rest
        (okCopy, copyDeps) <- templateForCopy typeEnv env insidePath typeName rest
        (okMembers, membersDeps) <- templatesForMembers typeEnv env insidePath typeName rest
        let funcs = okInit : okNew : okDelete : okCopy : okMembers
            moduleEnvWithBindings = addListOfBindings emptyTypeModuleEnv funcs
            typeModuleXObj = XObj (Mod moduleEnvWithBindings) i (Just ModuleTy)
            deps = deleteDeps ++ membersDeps ++ copyDeps
        return (typeModuleName, typeModuleXObj, deps)

-- | Make sure that the member declarations in a type definition
-- | Follow the pattern [<name> <type>, <name> <type>, ...]
-- | TODO: What a mess this function is, clean it up!
validateMembers :: [XObj] -> Maybe ()
validateMembers rest = if all (== True) (map validateOneCase rest)
                       then Just ()
                       else Nothing
  where
    validateOneCase :: XObj -> Bool
    validateOneCase (XObj (Arr arr) _ _) = length arr `mod` 2 == 0 &&
                                       all okMemberType (map snd (pairwise arr))
    validateOneCase XObj {} = False

    okMemberType :: XObj -> Bool
    okMemberType xobj = case xobjToTy xobj of
                          Just _ -> True
                          Nothing -> False

-- | Helper function to create the binder for the 'init' template.
templateForInit :: [String] -> String -> [XObj] -> Maybe (String, Binder)
templateForInit insidePath typeName [XObj (Arr membersXObjs) _ _] =
  Just $ instanceBinder (SymPath insidePath "init")
                        (FuncTy (initArgListTypes membersXObjs) (StructTy typeName []))
                        (templateInit StackAlloc typeName (memberXObjsToPairs membersXObjs))
templateForInit _ _ _ = Nothing

-- | Helper function to create the binder for the 'new' template.
templateForNew :: [String] -> String -> [XObj] -> Maybe (String, Binder)
templateForNew insidePath typeName [XObj (Arr membersXObjs) _ _] =
  Just $ instanceBinder (SymPath insidePath "new")
                        (FuncTy (initArgListTypes membersXObjs) (PointerTy (StructTy typeName [])))
                        (templateInit HeapAlloc typeName (memberXObjsToPairs membersXObjs))
templateForNew _ _ _ = Nothing

-- | Generate a list of types from a deftype declaration.
initArgListTypes :: [XObj] -> [Ty]
initArgListTypes xobjs = map (\(_, x) -> fromJust (xobjToTy x)) (pairwise xobjs)

-- | Helper function to create the binder for the 'delete' template.
templateForDelete :: Env -> Env -> [String] -> String -> [XObj] -> Maybe ((String, Binder), [XObj])
templateForDelete typeEnv env insidePath typeName [XObj (Arr membersXObjs) _ _] =
  Just $ (instanceBinderWithDeps (SymPath insidePath "delete")
                                 (FuncTy [(StructTy typeName [])] UnitTy)
                                 (templateDelete typeEnv env (memberXObjsToPairs membersXObjs)))
templateForDelete _ _ _ _ _ = Nothing

-- | Helper function to create the binder for the 'copy' template.
templateForCopy :: Env -> Env -> [String] -> String -> [XObj] -> Maybe ((String, Binder), [XObj])
templateForCopy typeEnv env insidePath typeName [XObj (Arr membersXObjs) _ _] =
  Just $ (instanceBinderWithDeps (SymPath insidePath "copy")
                                 (FuncTy [(RefTy (StructTy typeName []))] (StructTy typeName []))
                                 (templateCopy typeEnv env (memberXObjsToPairs membersXObjs)))
templateForCopy _ _ _ _ _ = Nothing

-- | Get a list of pairs from a deftype declaration.
memberXObjsToPairs :: [XObj] -> [(String, Ty)]
memberXObjsToPairs xobjs = map (\(n, t) -> (getName n, fromJust (xobjToTy t))) (pairwise xobjs)

-- | Generate all the templates for ALL the member variables in a deftype declaration.
templatesForMembers :: Env -> Env -> [String] -> String -> [XObj] -> Maybe ([(String, Binder)], [XObj])
templatesForMembers typeEnv env insidePath typeName [XObj (Arr membersXobjs) _ _] =
  let bindersAndDeps = concatMap (templatesForSingleMember typeEnv env insidePath typeName) (pairwise membersXobjs)
  in  Just (map fst bindersAndDeps, concatMap snd bindersAndDeps)
templatesForMembers _ _ _ _ _ = error "Can't create member functions for type with more than one case (yet)."

-- | Generate the templates for a single member in a deftype declaration.
templatesForSingleMember :: Env -> Env -> [String] -> String -> (XObj, XObj) -> [((String, Binder), [XObj])]
templatesForSingleMember typeEnv env insidePath typeName (nameXObj, typeXObj) =
  let Just t = xobjToTy typeXObj
      p = StructTy typeName []
      memberName = getName nameXObj
      fixedMemberTy = if isManaged t then (RefTy t) else t
  in [instanceBinderWithDeps (SymPath insidePath memberName) (FuncTy [(RefTy p)] fixedMemberTy) (templateGetter memberName fixedMemberTy)
     ,instanceBinderWithDeps (SymPath insidePath ("set-" ++ memberName)) (FuncTy [p, t] p) (templateSetter typeEnv env memberName t)
     ,instanceBinderWithDeps (SymPath insidePath ("update-" ++ memberName))
                                                            (FuncTy [p, (FuncTy [t] t)] p)
                                                            (templateUpdater memberName)]

-- | The template for the 'init' and 'new' functions for a deftype.
templateInit :: AllocationMode -> String -> [(String, Ty)] -> Template
templateInit allocationMode typeName members =
  Template
    (FuncTy [] (VarTy "p"))
    (const (toTemplate $ "$p $NAME(" ++ joinWithComma (map memberArg members) ++ ")"))
    (const (toTemplate $ unlines [ "$DECL {"
                                 , case allocationMode of
                                     StackAlloc -> "    $p instance;"
                                     HeapAlloc ->  "    $p instance = CARP_MALLOC(sizeof(" ++ typeName ++ "));"
                                 , joinWith "\n" (map (memberAssignment allocationMode) members) 
                                 , "    return instance;"
                                 , "}"]))
    (const [])

-- | Creates the C code for an arg to the init function.
-- | i.e. "(deftype A [x Int])" will generate "int x" which
-- | will be used in the init function like this: "A_init(int x)"
memberArg :: (String, Ty) -> String
memberArg (memberName, memberTy) = tyToC memberTy ++ " " ++ memberName

-- | Generate C code for assigning to a member variable.
-- | Needs to know if the instance is a pointer or stack variable.
memberAssignment :: AllocationMode -> (String, Ty) -> String
memberAssignment allocationMode (memberName, _) = "    instance" ++ sep ++ memberName ++ " = " ++ memberName ++ ";"
  where sep = case allocationMode of
                StackAlloc -> "."
                HeapAlloc -> "->"

-- | The template for getters of a deftype.
templateGetter :: String -> Ty -> Template
templateGetter member fixedMemberTy =
  let maybeAmpersand = case fixedMemberTy of
                         RefTy _ -> "&"
                         _ -> ""
  in 
  Template
    (FuncTy [RefTy (VarTy "p")] (VarTy "t"))
    (const (toTemplate "$t $NAME($(Ref p) p)"))
    (const (toTemplate ("$DECL { return " ++ maybeAmpersand ++ "(p->" ++ member ++ "); }\n")))
    (const [])

-- | The template for setters of a deftype.
templateSetter :: Env -> Env -> String -> Ty -> Template
templateSetter typeEnv env memberName memberTy =
  let callToDelete = memberDeletion env (memberName, memberTy)
  in
  Template
    (FuncTy [VarTy "p", VarTy "t"] (VarTy "p"))
    (const (toTemplate "$p $NAME($p p, $t newValue)"))
    (const (toTemplate (unlines ["$DECL {"
                                ,callToDelete
                                ,"    p." ++ memberName ++ " = newValue;"
                                ,"    return p;"
                                ,"}\n"])))
    (\_ -> if isManaged memberTy
           then (depsOfPolymorphicFunction typeEnv env "delete" (memberTypeToDeleterType memberTy))
           else [])

-- | The template for updater functions of a deftype
-- | (allows changing a variable by passing an transformation function).
templateUpdater :: String -> Template
templateUpdater member =
  Template
    (FuncTy [VarTy "p", (FuncTy [VarTy "t"] (VarTy "t"))] (VarTy "p"))
    (const (toTemplate "$p $NAME($p p, $(Fn [t] t) updater)"))
    (const (toTemplate (unlines ["$DECL {"
                                ,"    p." ++ member ++ " = updater(p." ++ member ++ ");"
                                ,"    return p;"
                                ,"}\n"])))
    (\(FuncTy [_, t] _) -> [defineFunctionTypeAlias t])

-- | The template for the 'delete' function of a deftype.
templateDelete :: Env -> Env -> [(String, Ty)] -> Template
templateDelete typeEnv env members =
  Template
   (FuncTy [(VarTy "p")] UnitTy)
   (const (toTemplate $ "void $NAME($p p)"))
   (const (toTemplate $ unlines [ "$DECL {"
                                , (joinWith "\n" (map (memberDeletion env) members)) 
                                , "}"]))
   (\_ -> concatMap (depsOfPolymorphicFunction typeEnv env "delete" . memberTypeToDeleterType)
                    (filter isManaged (map snd members)))

-- | Given a member type, get the type of the member's deleter function.
memberTypeToDeleterType :: Ty -> Ty
memberTypeToDeleterType memberType =
  (FuncTy [memberType] UnitTy)

-- | Generate the C code for deleting a single member of the deftype.
-- | TODO: Should return an Either since this can fail!
memberDeletion :: Env -> (String, Ty) -> String
memberDeletion env (memberName, t)
  | isManaged t =
    case filter ((\(Just t') -> (areUnifiable (FuncTy [t] UnitTy) t')) . ty . binderXObj . snd) (multiLookupALL "delete" env) of
      [] -> "    /* Can't find any delete-function for member '" ++ memberName ++ "' */"
      [(_, Binder single)] ->
        let Just t' = ty single
            (SymPath pathStrings name) = getPath single
            suffix = polymorphicSuffix t' (FuncTy [t] UnitTy)
            concretizedPath = SymPath pathStrings (name ++ suffix)
        in  "    " ++ pathToC concretizedPath ++ "(p." ++ memberName ++ ");"
      _ -> "    /* Can't find a single delete-function for member '" ++ memberName ++ "' */"
  | otherwise   = "    /* Ignore non-managed member '" ++ memberName ++ "' */"



---------------------------------------------------------------------
-- Copy members, replace with "nameOfPolymorphicFunction" in Infer.hs

templateCopy :: Env -> Env -> [(String, Ty)] -> Template
templateCopy typeEnv env members =
  Template
   (FuncTy [(RefTy (VarTy "p"))] (VarTy "p"))
   (const (toTemplate $ "$p $NAME($p* pRef)"))
   (const (toTemplate $ unlines [ "$DECL {"
                                , "    $p copy = *pRef;"
                                , (joinWith "\n" (map (memberCopy env) members))
                                , "    return copy;"
                                , "}"]))
   (\_ -> concatMap (depsOfPolymorphicFunction typeEnv env "copy" . memberTypeToCopyFunctionType)
                    (filter isManaged (map snd members)))

-- | The type of a member's copying function.
memberTypeToCopyFunctionType :: Ty -> Ty
memberTypeToCopyFunctionType memberType =
  (FuncTy [(RefTy memberType)] memberType)  

memberCopy :: Env -> (String, Ty) -> String
memberCopy env (memberName, t)
  | isManaged t =
    case filter ((\(Just t') -> (areUnifiable (FuncTy [(RefTy t)] t) t')) . ty . binderXObj . snd) (multiLookupALL "copy" env) of
      [] -> "    /* Can't find any copy-function for member '" ++ memberName ++ "' */"
      [(_, Binder single)] ->
        let Just t' = ty single
            (SymPath pathStrings name) = getPath single
            suffix = polymorphicSuffix t' (FuncTy [(RefTy t)] t)
            concretizedPath = SymPath pathStrings (name ++ suffix)
        in  "    copy." ++ memberName ++ " = " ++ pathToC concretizedPath ++ "(&(pRef->" ++ memberName ++ "));"
      _ -> "    /* Can't find a single copy-function for member '" ++ memberName ++ "' */"
  | otherwise   = "    /* Ignore non-managed member '" ++ memberName ++ "' */"

